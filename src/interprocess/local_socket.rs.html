<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `&#x2F;home&#x2F;runner&#x2F;.cargo&#x2F;registry&#x2F;src&#x2F;github.com-1ecc6299db9ec823&#x2F;interprocess-1.1.1&#x2F;src&#x2F;local_socket.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>local_socket.rs - source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../interprocess/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
</pre><pre class="rust"><code><span class="doccomment">//! Local sockets, an IPC primitive featuring a server and multiple clients connecting to that server using a filesystem path inside a special namespace, each having a private connection to that server.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Local sockets are not a real IPC method implemented by the OS — they were introduced because of the difference between named pipes on Windows and Unix: named pipes on Windows are almost the same as Unix domain sockets on Linux while Unix named pipes (which are referred to as FIFO files in this crate to avoid confusion) are like unnamed pipes but identifiable with a filesystem path: there&#39;s no distinction between writers and the first reader takes all. **Simply put, local sockets use named pipes on Windows and Unix domain sockets on Unix.**</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Platform-specific namespaces</span>
<span class="doccomment">//! There&#39;s one more problem regarding platform differences: since only Linux supports putting Ud-sockets in a separate namespace which is isolated from the filesystem, the `LocalSocketName`/`LocalSocketNameBuf` types are used to identify local sockets rather than `OsStr`/`OsString`: on Unix platforms other than Linux, which includes macOS, all flavors of BSD and possibly other Unix-like systems, the only way to name a Ud-socket is to use a filesystem path. As such, those platforms don&#39;t have the namespaced socket creation method available. Complicatng matters further, Windows does not support named pipes in the normal filesystem, meaning that namespaced local sockets are the only functional method on Windows. As a way to solve this issue, `LocalSocketName`/`LocalSocketNameBuf` only provide creation in a platform-specific way, meaning that crate users are required to use conditional compilation to decide on the name for the socket names.</span>

<span class="kw">use</span> <span class="ident">std</span>::{
    <span class="ident">borrow::Cow</span>,
    <span class="ident">ffi</span>::{<span class="ident">CStr</span>, <span class="ident">CString</span>, <span class="ident">OsStr</span>, <span class="ident">OsString</span>},
    <span class="ident">fmt</span>::{<span class="self">self</span>, <span class="ident">Debug</span>, <span class="ident">Formatter</span>},
    <span class="ident">io</span>::{<span class="self">self</span>, <span class="ident">prelude</span>::<span class="kw-2">*</span>, <span class="ident">IoSlice</span>, <span class="ident">IoSliceMut</span>},
    <span class="ident">iter::FusedIterator</span>,
    <span class="ident">path</span>::{<span class="ident">Path</span>, <span class="ident">PathBuf</span>},
    <span class="ident">str</span>,
};

<span class="macro">impmod!</span> {<span class="ident">local_socket</span>,
    <span class="ident">name_type_support_query</span> <span class="kw">as</span> <span class="ident">name_type_support_query_impl</span>,
    <span class="ident">NAME_TYPE_ALWAYS_SUPPORTED</span> <span class="kw">as</span> <span class="ident">NAME_TYPE_ALWAYS_SUPPORTED_REAL</span>,
    <span class="ident">to_local_socket_name_osstr</span>,
    <span class="ident">to_local_socket_name_osstring</span>,
    <span class="ident">LocalSocketListener</span> <span class="kw">as</span> <span class="ident">LocalSocketListenerImpl</span>,
    <span class="ident">LocalSocketStream</span> <span class="kw">as</span> <span class="ident">LocalSocketStreamImpl</span>,
}

<span class="doccomment">/// A local socket server, listening for connections.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Example</span>
<span class="doccomment">/// ```no_run</span>
<span class="doccomment">/// use interprocess::local_socket::{LocalSocketListener, LocalSocketStream};</span>
<span class="doccomment">/// use std::io::{self, prelude::*, BufReader};</span>
<span class="doccomment">///</span>
<span class="doccomment">/// fn handle_error(conn: io::Result&lt;LocalSocketStream&gt;) -&gt; Option&lt;LocalSocketStream&gt; {</span>
<span class="doccomment">///     match conn {</span>
<span class="doccomment">///         Ok(val) =&gt; Some(val),</span>
<span class="doccomment">///         Err(error) =&gt; {</span>
<span class="doccomment">///             eprintln!(&quot;Incoming connection failed: {}&quot;, error);</span>
<span class="doccomment">///             None</span>
<span class="doccomment">///         }</span>
<span class="doccomment">///     }</span>
<span class="doccomment">/// }</span>
<span class="doccomment">///</span>
<span class="doccomment">/// let listener = LocalSocketListener::bind(&quot;/tmp/example.sock&quot;)?;</span>
<span class="doccomment">/// for mut conn in listener.incoming().filter_map(handle_error) {</span>
<span class="doccomment">///     conn.write_all(b&quot;Hello from server!\n&quot;)?;</span>
<span class="doccomment">///     let mut conn = BufReader::new(conn);</span>
<span class="doccomment">///     let mut buffer = String::new();</span>
<span class="doccomment">///     conn.read_line(&amp;mut buffer);</span>
<span class="doccomment">///     println!(&quot;Client answered: {}&quot;, buffer);</span>
<span class="doccomment">/// }</span>
<span class="doccomment">/// # Ok::&lt;(), Box&lt;dyn std::error::Error&gt;&gt;(())</span>
<span class="doccomment">/// ```</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">LocalSocketListener</span> {
    <span class="ident">inner</span>: <span class="ident">LocalSocketListenerImpl</span>,
}
<span class="kw">impl</span> <span class="ident">LocalSocketListener</span> {
    <span class="doccomment">/// Creates a socket server with the specified local socket name.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bind</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="ident">name</span>: <span class="kw">impl</span> <span class="ident">ToLocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="prelude-val">Ok</span>(<span class="self">Self</span> {
            <span class="ident">inner</span>: <span class="ident">LocalSocketListenerImpl::bind</span>(<span class="ident">name</span>)<span class="question-mark">?</span>,
        })
    }
    <span class="doccomment">/// Listens for incoming connections to the socket, blocking until a client is connected.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// See [`incoming`] for a convenient way to create a main loop for a server.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`incoming`]: #method.incoming &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">accept</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">LocalSocketStream</span><span class="op">&gt;</span> {
        <span class="prelude-val">Ok</span>(<span class="ident">LocalSocketStream</span> {
            <span class="ident">inner</span>: <span class="self">self</span>.<span class="ident">inner</span>.<span class="ident">accept</span>()<span class="question-mark">?</span>,
        })
    }
    <span class="doccomment">/// Creates an infinite iterator which calls `accept()` with each iteration. Used together with `for` loops to conveniently create a main loop for a socket server.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Example</span>
    <span class="doccomment">/// See the struct-level documentation for a full example which already uses this method.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">incoming</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">Incoming</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span> {
        <span class="ident">Incoming::from</span>(<span class="self">self</span>)
    }
    <span class="doccomment">/// Enables or disables the nonblocking mode for the listener. By default, it is disabled.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// In nonblocking mode, calling [`accept`] and iterating through [`incoming`] will immediately return a [`WouldBlock`] error if there is no client attempting to connect at the moment instead of blocking until one arrives.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Platform-specific behavior</span>
    <span class="doccomment">/// ## Windows</span>
    <span class="doccomment">/// The nonblocking mode will be also be set for the streams produced by [`accept`] and [`incoming`], both existing and new ones.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`WouldBlock`]: https://doc.rust-lang.org/std/io/enum.ErrorKind.html#variant.WouldBlock &quot; &quot;</span>
    <span class="doccomment">/// [`accept`]: #method.accept &quot; &quot;</span>
    <span class="doccomment">/// [`incoming`]: #method.incoming &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_nonblocking</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">nonblocking</span>: <span class="ident">bool</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">inner</span>.<span class="ident">set_nonblocking</span>(<span class="ident">nonblocking</span>)
    }
}
<span class="kw">impl</span> <span class="ident">Debug</span> <span class="kw">for</span> <span class="ident">LocalSocketListener</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) -&gt; <span class="ident">fmt::Result</span> {
        <span class="ident">Debug::fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">inner</span>, <span class="ident">f</span>)
    }
}

<span class="doccomment">/// An infinite iterator over incoming client connections of a [`LocalSocketListener`].</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This iterator is created by the [`incoming`] method on [`LocalSocketListener`] — see its documentation for more.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// [`LocalSocketListener`]: struct.LocalSocketListener.html &quot; &quot;</span>
<span class="doccomment">/// [`incoming`]: struct.LocalSocketListener.html#method.incoming &quot; &quot;</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Incoming</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">listener</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">LocalSocketListener</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">From</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">LocalSocketListener</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Incoming</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">listener</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">LocalSocketListener</span>) -&gt; <span class="self">Self</span> {
        <span class="self">Self</span> { <span class="ident">listener</span> }
    }
}
<span class="kw">impl</span> <span class="ident">Iterator</span> <span class="kw">for</span> <span class="ident">Incoming</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span> {
    <span class="kw">type</span> <span class="ident">Item</span> <span class="op">=</span> <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">LocalSocketStream</span><span class="op">&gt;</span>;
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">next</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident"><span class="self">Self</span>::Item</span><span class="op">&gt;</span> {
        <span class="prelude-val">Some</span>(<span class="self">self</span>.<span class="ident">listener</span>.<span class="ident">accept</span>())
    }
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">size_hint</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; (<span class="ident">usize</span>, <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span>) {
        (<span class="ident">usize::MAX</span>, <span class="prelude-val">None</span>)
    }
}
<span class="kw">impl</span> <span class="ident">FusedIterator</span> <span class="kw">for</span> <span class="ident">Incoming</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span> {}

<span class="doccomment">/// A local socket byte stream, obtained eiter from [`LocalSocketListener`] or by connecting to an existing local socket.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Example</span>
<span class="doccomment">/// ```no_run</span>
<span class="doccomment">/// use interprocess::local_socket::LocalSocketStream;</span>
<span class="doccomment">/// use std::io::{prelude::*, BufReader};</span>
<span class="doccomment">///</span>
<span class="doccomment">/// // Replace the path as necessary on Windows.</span>
<span class="doccomment">/// let mut conn = LocalSocketStream::connect(&quot;/tmp/example.sock&quot;)?;</span>
<span class="doccomment">/// conn.write_all(b&quot;Hello from client!\n&quot;)?;</span>
<span class="doccomment">/// let mut conn = BufReader::new(conn);</span>
<span class="doccomment">/// let mut buffer = String::new();</span>
<span class="doccomment">/// conn.read_line(&amp;mut buffer)?;</span>
<span class="doccomment">/// println!(&quot;Server answered: {}&quot;, buffer);</span>
<span class="doccomment">/// # Ok::&lt;(), Box&lt;dyn std::error::Error&gt;&gt;(())</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// [`LocalSocketListener`]: struct.LocalSocketListener.html &quot; &quot;</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">LocalSocketStream</span> {
    <span class="ident">inner</span>: <span class="ident">LocalSocketStreamImpl</span>,
}
<span class="kw">impl</span> <span class="ident">LocalSocketStream</span> {
    <span class="doccomment">/// Connects to a remote local socket server.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">connect</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="ident">name</span>: <span class="kw">impl</span> <span class="ident">ToLocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="prelude-val">Ok</span>(<span class="self">Self</span> {
            <span class="ident">inner</span>: <span class="ident">LocalSocketStreamImpl::connect</span>(<span class="ident">name</span>)<span class="question-mark">?</span>,
        })
    }
    <span class="doccomment">/// Retrieves the identifier of the process on the opposite end of the local socket connection.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Platform-specific behavior</span>
    <span class="doccomment">/// ## macOS and iOS</span>
    <span class="doccomment">/// Not supported by the OS, will always generate an error at runtime.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`FromRawHandle`]: https://doc.rust-lang.org/std/os/windows/io/trait.FromRawHandle.html &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">peer_pid</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">inner</span>.<span class="ident">peer_pid</span>()
    }
    <span class="doccomment">/// Enables or disables the nonblocking mode for the stream. By default, it is disabled.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// In nonblocking mode, reading and writing will immediately return with the [`WouldBlock`] error in situations when they would normally block for an uncontrolled amount of time. The specific situations are:</span>
    <span class="doccomment">/// - When reading is attempted and there is no new data available;</span>
    <span class="doccomment">/// - When writing is attempted and the buffer is full due to the other side not yet having read previously sent data.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`WouldBlock`]: https://doc.rust-lang.org/std/io/enum.ErrorKind.html#variant.WouldBlock &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_nonblocking</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">nonblocking</span>: <span class="ident">bool</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">inner</span>.<span class="ident">set_nonblocking</span>(<span class="ident">nonblocking</span>)
    }
}
<span class="kw">impl</span> <span class="ident">Read</span> <span class="kw">for</span> <span class="ident">LocalSocketStream</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">read</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">buf</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">u8</span>]) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">inner</span>.<span class="ident">read</span>(<span class="ident">buf</span>)
    }
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">read_vectored</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">bufs</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">IoSliceMut</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>]) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">inner</span>.<span class="ident">read_vectored</span>(<span class="ident">bufs</span>)
    }
}
<span class="kw">impl</span> <span class="ident">Write</span> <span class="kw">for</span> <span class="ident">LocalSocketStream</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">write</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">buf</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">inner</span>.<span class="ident">write</span>(<span class="ident">buf</span>)
    }
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">write_vectored</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">bufs</span>: <span class="kw-2">&amp;</span>[<span class="ident">IoSlice</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>]) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">inner</span>.<span class="ident">write_vectored</span>(<span class="ident">bufs</span>)
    }
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">flush</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">inner</span>.<span class="ident">flush</span>()
    }
}
<span class="kw">impl</span> <span class="ident">Debug</span> <span class="kw">for</span> <span class="ident">LocalSocketStream</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) -&gt; <span class="ident">fmt::Result</span> {
        <span class="ident">Debug::fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">inner</span>, <span class="ident">f</span>)
    }
}
<span class="macro">impl_handle_manip!</span>(<span class="ident">LocalSocketStream</span>);

<span class="doccomment">/// A name for a local socket.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Due to vast differences between platforms in terms of how local sockets are named, there needs to be a way to store and process those in a unified way while also retaining platform-specific pecularities. `LocalSocketName` aims to bridge the gap between portability and platform-specific correctness.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Creation</span>
<span class="doccomment">/// A separate trait is used to create names from basic strings: [`ToLocalSocketName`]. Aside from being conveniently implemented on every single string type in the standard library, it also provides some special processing. Please read its documentation if you haven&#39;t already — the rest of this page assumes you did.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Validity</span>
<span class="doccomment">/// As mentioned in the [module-level documentation], not all platforms support all types of local socket names. A name pointing to a filesystem location is only supported on Unix-like systems, and names pointing to an abstract namespace reserved specifically for local sockets are only available on Linux and Windows. Due to the diversity of those differences, `LocalSocketName` does not provide any forced validation by itself — the [`is_supported`] and [`is_always_supported`] checks are not enforced to succeed. Instead, they are intended as helpers for the process of user input validation, if any local socket names are ever read from environment variables, configuration files or other methods of user input.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// If an invalid local socket name is used to create a local socket or connect to it, the creation/connection method will fail.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// [`to_local_socket_name`]: trait.ToLocalSocketName.html &quot; &quot;</span>
<span class="doccomment">/// [module-level documentation]: index.html &quot; &quot;</span>
<span class="doccomment">/// [`is_supported`]: #method.is_supported &quot; &quot;</span>
<span class="doccomment">/// [`is_always_supported`]: #method.is_always_supported &quot; &quot;</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">LocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">inner</span>: <span class="ident">Cow</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">OsStr</span><span class="op">&gt;</span>,
    <span class="ident">namespaced</span>: <span class="ident">bool</span>,
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">LocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// Returns `true` if the type of the name is supported by the OS, `false` otherwise.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The check is performed at runtime. For a conservative compile-time check, see [`is_always_supported`].</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`is_always_supported`]: #method.is_always_supported &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">is_supported</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        (<span class="ident">NameTypeSupport::query</span>().<span class="ident">namespace_supported</span>() <span class="op">&amp;&amp;</span> <span class="self">self</span>.<span class="ident">is_namespaced</span>())
            <span class="op">|</span><span class="op">|</span> (<span class="ident">NameTypeSupport::query</span>().<span class="ident">paths_supported</span>() <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="self">self</span>.<span class="ident">is_path</span>())
    }
    <span class="doccomment">/// Returns `true` if the type of the name is supported by the OS, `false` otherwise.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// The check is performed at compile-time. For a check which might return a more permissive result on certain platforms by checking for support at runtime, see [`is_supported`].</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`is_supported`]: #method.is_supported &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">is_always_supported</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        (<span class="ident">NameTypeSupport::ALWAYS_AVAILABLE</span>.<span class="ident">namespace_supported</span>() <span class="op">&amp;&amp;</span> <span class="self">self</span>.<span class="ident">is_namespaced</span>())
            <span class="op">|</span><span class="op">|</span> (<span class="ident">NameTypeSupport::ALWAYS_AVAILABLE</span>.<span class="ident">paths_supported</span>() <span class="op">&amp;&amp;</span> <span class="self">self</span>.<span class="ident">is_path</span>())
    }
    <span class="doccomment">/// Returns `true` if the value is a namespaced name, `false` otherwise.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">is_namespaced</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="self">self</span>.<span class="ident">namespaced</span>
    }
    <span class="doccomment">/// Returns `true` if the value is a filesystem path, `false` otherwise.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">is_path</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="op">!</span><span class="self">self</span>.<span class="ident">namespaced</span>
    }
    <span class="doccomment">/// Returns the name as an `OsStr`. The returned value does not retain the type of the name (whether it was a filesystem path or a namespaced name).</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If you need the value as an owned `OsString` instead, see [`into_inner`].</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`into_inner`]: #method.into_inner &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">inner</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">OsStr</span> {
        <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">inner</span>
    }
    <span class="doccomment">/// Returns the name as an `OsString`. The returned value does not retain the type of the name (whether it was a filesystem path or a namespaced name).</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If you need the value as a borrowed `OsStr` instead, see [`inner`].</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`inner`]: #method.inner &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">into_inner</span>(<span class="self">self</span>) -&gt; <span class="ident">OsString</span> {
        <span class="self">self</span>.<span class="ident">inner</span>.<span class="ident">into_owned</span>()
    }
    <span class="doccomment">/// Returns the name as a *borrowed* `Cow&lt;&#39;_, OsStr&gt;`. The returned value does not retain the type of the name (whether it was a filesystem path or a namespaced name).</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If you need the value as a borrowed `OsStr`, see [`inner`]; if you need the value as an owned `OsString`, see [`into_inner`].  If you need to take ownership of the `Cow`, see `into_inner_cow`.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`inner`]: #method.inner &quot; &quot;</span>
    <span class="doccomment">/// [`into_inner`]: #method.into_inner &quot; &quot;</span>
    <span class="doccomment">/// [`into_inner_cow`]: #method.into_inner_cow &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">inner_cow</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Cow</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">OsStr</span><span class="op">&gt;</span> {
        <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">inner</span>
    }
    <span class="doccomment">/// Returns the name as a `Cow&lt;&#39;_, OsStr&gt;`. The returned value does not retain the type of the name (whether it was a filesystem path or a namespaced name).</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If you need the value as a borrowed `OsStr`, see [`inner`]; if you need the value as an owned `OsString`, see [`into_inner`]. If you don&#39;t need to take ownership of the `Cow`, see `inner_cow`.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`inner`]: #method.inner &quot; &quot;</span>
    <span class="doccomment">/// [`into_inner`]: #method.into_inner &quot; &quot;</span>
    <span class="doccomment">/// [`inner_cow`]: #method.inner_cow &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">into_inner_cow</span>(<span class="self">self</span>) -&gt; <span class="ident">Cow</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">OsStr</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">inner</span>
    }
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">from_raw_parts</span>(<span class="ident">inner</span>: <span class="ident">Cow</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">OsStr</span><span class="op">&gt;</span>, <span class="ident">namespaced</span>: <span class="ident">bool</span>) -&gt; <span class="self">Self</span> {
        <span class="self">Self</span> { <span class="ident">inner</span>, <span class="ident">namespaced</span> }
    }
}

<span class="doccomment">/// Represents which kinds of identifiers can be used for a local socket&#39;s name on the current platform.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>, <span class="ident">Hash</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">NameTypeSupport</span> {
    <span class="doccomment">/// Only filesystem paths can be used.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This is true for all Unix/POSIX and Unix-like systems other than Linux.</span>
    <span class="ident">OnlyPaths</span>,
    <span class="doccomment">/// Only names in an dedicated namespace can be used.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This is true only for Windows.</span>
    <span class="ident">OnlyNamespaced</span>,
    <span class="doccomment">/// Both of the above options are available.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This is true only for Linux.</span>
    <span class="ident">Both</span>,
}
<span class="kw">impl</span> <span class="ident">NameTypeSupport</span> {
    <span class="doccomment">/// The types of local socket names supported on the current platform regardless of the environment and OS version.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// On most platforms, the value is known at compile time, i.e. the support for paths wasn&#39;t introduced in a specific version of the OS or isn&#39;t known to be supported at all. **Currently, this includes all supported OSes.** If support is added for an OS which added this functionality in a specific version, this constant will be the most restrictive value for that platform, with [`query`] possibly returning the actual value according to the current version of the OS.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Simply put, you should probably just use this value for consistency across platforms, unless you really need a specific name type to be supported.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`query`]: #method.query &quot; &quot;</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ALWAYS_AVAILABLE</span>: <span class="self">Self</span> <span class="op">=</span> <span class="ident">NAME_TYPE_ALWAYS_SUPPORTED_REAL</span>;
    <span class="doccomment">/// Returns the types of local socket names supported on the current platform with the current environment.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// On most platforms, the value is known at compile time, i.e. the support for one of the types wasn&#39;t introduced in an update to the OS or isn&#39;t known to be supported at all. **Currently, this includes all supported OSes.** For compatibility with OSes which might add the functionality in the future starting with a specific version, this function isn&#39;t a `const fn` — see [`ALWAYS_AVAILABLE`] if you need a constant expression.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`ALWAYS_AVAILABLE`]: #associatedconstant.ALWAYS_AVAILABLE &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">query</span>() -&gt; <span class="self">Self</span> {
        <span class="ident">name_type_support_query_impl</span>()
    }

    <span class="doccomment">/// Returns `true` if, according to `self`, filesystem-based local sockets are supported; `false` otherwise.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">paths_supported</span>(<span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="macro">matches!</span>(<span class="self">self</span>, <span class="ident"><span class="self">Self</span>::OnlyPaths</span> <span class="op">|</span> <span class="ident"><span class="self">Self</span>::Both</span>)
    }
    <span class="doccomment">/// Returns `true` if, according to `self`, namespaced local socket names are supported; `false` otherwise.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">namespace_supported</span>(<span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="macro">matches!</span>(<span class="self">self</span>, <span class="ident"><span class="self">Self</span>::OnlyNamespaced</span> <span class="op">|</span> <span class="ident"><span class="self">Self</span>::Both</span>)
    }
}
<span class="doccomment">/// Types which can be converted to a local socket name.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The difference between this trait and [`TryInto`]`&lt;`[`LocalSocketName`]`&gt;` is that the latter does not constrain the error type to be [`io::Error`] and thus is not compatible with many types from the standard library which are widely expected to be convertible to Unix domain socket paths. Additionally, this makes the special syntax for namespaced sockets possible (see below).</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ## `@` syntax for namespaced paths</span>
<span class="doccomment">/// As mentioned in the [`LocalSocketName` documentation][`LocalSocketName`], there are two types of which local socket names can be: filesystem paths and namespaced names. Those are isolated from each other — there&#39;s no portable way to represent one using another, though certain OSes might provide ways to do so — Windows does, for example. To be able to represent both in a platform-independent fashion, a special syntax was implemented in implementations of this trait on types from the standard library: &quot;@ syntax&quot;.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The feature, in its core, is extremely simple: if the first character in a string is the @ character, the value of the string is interpreted and stored as a namespaced name (otherwise, it&#39;s treated as a filesystem path); the @ character is then removed from the string (by taking a subslice which dosen&#39;t include it if a string slice is being used; for owned strings, it&#39;s simply removed from the string by shifting the entire string towards the beginning). **[`Path`] and [`PathBuf`] are not affected at all — those have explicit path semantics and therefore cannot logically represent namespaced names.**</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This feature is extremely useful both when using hardcoded literals and accepting user input for the path, but sometimes you might want to prevent this behavior. In such a case, you have the following possible approaches:</span>
<span class="doccomment">/// - If the string is a [`OsStr`]/[`OsString`], it can be cheaply converted to a [`Path`]/[`PathBuf`], which do not support the @ syntax</span>
<span class="doccomment">/// - If the string is a [`str`]/[`String`], it can be cheaply converted to [`OsStr`]/[`OsString`]; then the above method can be applied</span>
<span class="doccomment">/// - If the string is a [`CStr`]/[`CString`], it can be converted to [`str`]/[`String`] using the following code:</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">/// # use std::{</span>
<span class="doccomment">/// #     str::Utf8Error,</span>
<span class="doccomment">/// #     ffi::{CStr, CString},</span>
<span class="doccomment">/// # };</span>
<span class="doccomment">/// fn cstr_to_str(val: &amp;CStr) -&gt; Result&lt;&amp;str, Utf8Error&gt; {</span>
<span class="doccomment">///     std::str::from_utf8(val.to_bytes_with_nul())</span>
<span class="doccomment">/// }</span>
<span class="doccomment">/// fn cstring_to_string(val: CString) -&gt; String {</span>
<span class="doccomment">///     String::from_utf8_lossy(&amp;val.into_bytes_with_nul()).into()</span>
<span class="doccomment">/// }</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">/// Then, the method for [`str`]/[`String`] can be applied.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// None of the above conversions perform memory allocations — the only expensive one is [`CStr`]/[`CString`] which performs a check for valid UTF-8.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// [`LocalSocketName`]: struct.LocalSocketName.html &quot; &quot;</span>
<span class="doccomment">/// [`TryInto`]: https://doc.rust-lang.org/std/convert/trait.TryInto.html &quot; &quot;</span>
<span class="doccomment">/// [`str`]: https://doc.rust-lang.org/std/primitive.str.html &quot; &quot;</span>
<span class="doccomment">/// [`String`]: https://doc.rust-lang.org/std/string/struct.String.html &quot; &quot;</span>
<span class="doccomment">/// [`OsStr`]: https://doc.rust-lang.org/std/ffi/struct.OsStr.html &quot; &quot;</span>
<span class="doccomment">/// [`OsString`]: https://doc.rust-lang.org/std/ffi/struct.OsString.html &quot; &quot;</span>
<span class="doccomment">/// [`CStr`]: https://doc.rust-lang.org/std/ffi/struct.CStr.html &quot; &quot;</span>
<span class="doccomment">/// [`CString`]: https://doc.rust-lang.org/std/ffi/struct.CString.html &quot; &quot;</span>
<span class="doccomment">/// [`Path`]: https://doc.rust-lang.org/std/path/struct.Path.html &quot; &quot;</span>
<span class="doccomment">/// [`PathBuf`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html &quot; &quot;</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">ToLocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="doccomment">/// Performs the conversion to a local socket name.</span>
    <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">clippy::wrong_self_convention</span>)]</span> <span class="comment">// shut the fuck up</span>
    <span class="kw">fn</span> <span class="ident">to_local_socket_name</span>(<span class="self">self</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">LocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span><span class="op">&gt;</span>;
}
<span class="comment">// TODO document inpls for symmetry with ud-sockets</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">ToLocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Path</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">to_local_socket_name</span>(<span class="self">self</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">LocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span><span class="op">&gt;</span> {
        <span class="prelude-val">Ok</span>(<span class="ident">LocalSocketName::from_raw_parts</span>(
            <span class="ident">Cow::Borrowed</span>(<span class="self">self</span>.<span class="ident">as_os_str</span>()),
            <span class="bool-val">false</span>,
        ))
    }
}
<span class="kw">impl</span> <span class="ident">ToLocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;static</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">PathBuf</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">to_local_socket_name</span>(<span class="self">self</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">LocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;static</span><span class="op">&gt;</span><span class="op">&gt;</span> {
        <span class="prelude-val">Ok</span>(<span class="ident">LocalSocketName::from_raw_parts</span>(
            <span class="ident">Cow::Owned</span>(<span class="self">self</span>.<span class="ident">into_os_string</span>()),
            <span class="bool-val">false</span>,
        ))
    }
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">ToLocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">OsStr</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">to_local_socket_name</span>(<span class="self">self</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">LocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span><span class="op">&gt;</span> {
        <span class="prelude-val">Ok</span>(<span class="ident">to_local_socket_name_osstr</span>(<span class="self">self</span>))
    }
}
<span class="kw">impl</span> <span class="ident">ToLocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;static</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">OsString</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">to_local_socket_name</span>(<span class="self">self</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">LocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;static</span><span class="op">&gt;</span><span class="op">&gt;</span> {
        <span class="prelude-val">Ok</span>(<span class="ident">to_local_socket_name_osstring</span>(<span class="self">self</span>))
    }
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">ToLocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span> {
    <span class="kw">fn</span> <span class="ident">to_local_socket_name</span>(<span class="self">self</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">LocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span><span class="op">&gt;</span> {
        <span class="ident">OsStr::new</span>(<span class="self">self</span>).<span class="ident">to_local_socket_name</span>()
    }
}
<span class="kw">impl</span> <span class="ident">ToLocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;static</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">String</span> {
    <span class="kw">fn</span> <span class="ident">to_local_socket_name</span>(<span class="self">self</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">LocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;static</span><span class="op">&gt;</span><span class="op">&gt;</span> {
        <span class="comment">// OsString docs misleadingly state that a conversion from String requires reallocating</span>
        <span class="comment">// and copying, but, according to the std sources, that is not true on any platforms.</span>
        <span class="ident">OsString::from</span>(<span class="self">self</span>).<span class="ident">to_local_socket_name</span>()
    }
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">ToLocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">CStr</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">to_local_socket_name</span>(<span class="self">self</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">LocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span><span class="op">&gt;</span> {
        <span class="ident">str::from_utf8</span>(<span class="self">self</span>.<span class="ident">to_bytes_with_nul</span>())
            .<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">to_local_socket_name_osstr</span>(<span class="ident">OsStr::new</span>(<span class="ident">x</span>)))
            .<span class="ident">map_err</span>(<span class="op">|</span><span class="ident">error</span><span class="op">|</span> <span class="ident">io::Error::new</span>(<span class="ident">io::ErrorKind::InvalidData</span>, <span class="ident">error</span>))
    }
}
<span class="kw">impl</span> <span class="ident">ToLocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;static</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">CString</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">to_local_socket_name</span>(<span class="self">self</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">LocalSocketName</span><span class="op">&lt;</span><span class="lifetime">&#39;static</span><span class="op">&gt;</span><span class="op">&gt;</span> {
        <span class="ident">String::from_utf8</span>(<span class="self">self</span>.<span class="ident">into_bytes_with_nul</span>())
            .<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">to_local_socket_name_osstring</span>(<span class="ident">OsString::from</span>(<span class="ident">x</span>)))
            .<span class="ident">map_err</span>(<span class="op">|</span><span class="ident">error</span><span class="op">|</span> <span class="ident">io::Error::new</span>(<span class="ident">io::ErrorKind::InvalidData</span>, <span class="ident">error</span>))
    }
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
<span class="kw">mod</span> <span class="ident">test</span> {
    <span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::local_socket</span>::{<span class="ident">LocalSocketListener</span>, <span class="ident">LocalSocketStream</span>};
    <span class="attribute">#[<span class="ident">test</span>]</span>
    <span class="kw">fn</span> <span class="ident">basic</span>() {
        <span class="kw">use</span> <span class="ident">std</span>::{
            <span class="ident">io</span>::{<span class="self">self</span>, <span class="ident">prelude</span>::<span class="kw-2">*</span>, <span class="ident">BufReader</span>},
            <span class="ident">sync</span>::{<span class="ident">Arc</span>, <span class="ident">Barrier</span>},
        };

        <span class="comment">// We&#39;re using a barrier here to avoid the client attempting to connect</span>
        <span class="comment">// before the server creates the socket</span>
        <span class="kw">let</span> <span class="ident">barrier</span> <span class="op">=</span> <span class="ident">Arc::new</span>(<span class="ident">Barrier::new</span>(<span class="number">2</span>));
        <span class="kw">let</span> <span class="ident">server_barrier</span> <span class="op">=</span> <span class="ident">Arc::clone</span>(<span class="kw-2">&amp;</span><span class="ident">barrier</span>);

        <span class="ident">std::thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
            <span class="kw">fn</span> <span class="ident">handle_error</span>(<span class="ident">connection</span>: <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">LocalSocketStream</span><span class="op">&gt;</span>) -&gt; <span class="ident">LocalSocketStream</span> {
                <span class="kw">match</span> <span class="ident">connection</span> {
                    <span class="prelude-val">Ok</span>(<span class="ident">val</span>) =&gt; <span class="ident">val</span>,
                    <span class="prelude-val">Err</span>(<span class="ident">error</span>) =&gt; {
                        <span class="macro">panic!</span>(<span class="string">&quot;Incoming connection failed: {}&quot;</span>, <span class="ident">error</span>);
                    }
                }
            }

            <span class="kw">let</span> <span class="ident">listener</span> <span class="op">=</span> <span class="ident">LocalSocketListener::bind</span>(<span class="string">&quot;/tmp/example.sock&quot;</span>).<span class="ident">unwrap</span>();
            <span class="ident">server_barrier</span>.<span class="ident">wait</span>();
            <span class="kw">for</span> <span class="kw-2">mut</span> <span class="ident">conn</span> <span class="kw">in</span> <span class="ident">listener</span>.<span class="ident">incoming</span>().<span class="ident">map</span>(<span class="ident">handle_error</span>) {
                <span class="macro">println!</span>(<span class="string">&quot;Incoming connection!&quot;</span>);
                <span class="ident">conn</span>.<span class="ident">write_all</span>(<span class="string">b&quot;Hello from server!\n&quot;</span>).<span class="ident">unwrap</span>();
                <span class="comment">// Add buffering to the connection to read a line.</span>
                <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">conn</span> <span class="op">=</span> <span class="ident">BufReader::new</span>(<span class="ident">conn</span>);
                <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="ident">String::new</span>();
                <span class="ident">conn</span>.<span class="ident">read_line</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buffer</span>).<span class="ident">unwrap</span>();
                <span class="macro">println!</span>(<span class="string">&quot;Client answered: {}&quot;</span>, <span class="ident">buffer</span>);
            }
        });

        <span class="ident">barrier</span>.<span class="ident">wait</span>();
        <span class="kw">let</span> <span class="ident">h2</span> <span class="op">=</span> <span class="ident">std::thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">conn</span> <span class="op">=</span> <span class="ident">LocalSocketStream::connect</span>(<span class="string">&quot;/tmp/example.sock&quot;</span>).<span class="ident">unwrap</span>();
            <span class="ident">conn</span>.<span class="ident">write_all</span>(<span class="string">b&quot;Hello from client!\n&quot;</span>).<span class="ident">unwrap</span>();
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">conn</span> <span class="op">=</span> <span class="ident">BufReader::new</span>(<span class="ident">conn</span>);
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="ident">String::new</span>();
            <span class="ident">conn</span>.<span class="ident">read_line</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buffer</span>).<span class="ident">unwrap</span>();
            <span class="macro">println!</span>(<span class="string">&quot;Server answered: {}&quot;</span>, <span class="ident">buffer</span>);
        });
        <span class="ident">h2</span>.<span class="ident">join</span>().<span class="ident">unwrap</span>();
    }
}
</code></pre></div>
</section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="interprocess" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script>
</body></html>