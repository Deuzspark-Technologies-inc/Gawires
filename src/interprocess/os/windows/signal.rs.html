<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `&#x2F;home&#x2F;runner&#x2F;.cargo&#x2F;registry&#x2F;src&#x2F;github.com-1ecc6299db9ec823&#x2F;interprocess-1.1.1&#x2F;src&#x2F;os&#x2F;windows&#x2F;signal.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>signal.rs - source</title><link rel="stylesheet" type="text/css" href="../../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../../../storage.js"></script><script src="../../../../crates.js"></script><noscript><link rel="stylesheet" href="../../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../../interprocess/index.html'><div class='logo-container rust-logo'><img src='../../../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../../../wheel.svg"></a></div></form></nav><section id="main" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
</pre><pre class="rust"><code><span class="doccomment">//! C signal support on Windows.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! A big difference from POSIX platforms is the amount of signals that Windows supports. Signals on Windows are therefore much less useful than POSIX ones.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! # Signal safe C functions</span>
<span class="doccomment">//! The C standard specifies that calling any functions *other than those ones* from a signal hook **results in undefined behavior**:</span>
<span class="doccomment">//! - `abort`</span>
<span class="doccomment">//! - `_Exit`</span>
<span class="doccomment">//! - `quick_exit`</span>
<span class="doccomment">//! - `signal`, but only if it is used for setting a handler for the same signal as the one being currently handled</span>
<span class="doccomment">//! - atomic C functions, but only the ones which are lock-free (practically never used in Rust since it has its own atomics which use compiler intrinsics)</span>
<span class="doccomment">//! - `atomic_is_lock_free`</span>

<span class="kw">use</span> <span class="ident"><span class="kw">super</span>::imports</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std</span>::{
    <span class="ident">convert</span>::{<span class="ident">TryFrom</span>, <span class="ident">TryInto</span>},
    <span class="ident">error::Error</span>,
    <span class="ident">fmt</span>::{<span class="self">self</span>, <span class="ident">Formatter</span>},
    <span class="ident">panic</span>, <span class="ident">process</span>,
};

<span class="doccomment">/// Installs the specified handler for the specified signal.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Example</span>
<span class="doccomment">/// ```no_run</span>
<span class="doccomment">/// # fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span>
<span class="doccomment">/// # #[cfg(all(windows, feature = &quot;signals&quot;))] {</span>
<span class="doccomment">/// use interprocess::os::windows::signal::{self, SignalType, SignalHandler};</span>
<span class="doccomment">///</span>
<span class="doccomment">/// let handler = unsafe {</span>
<span class="doccomment">///     // Since signal handlers are restricted to a specific set of C functions, creating a</span>
<span class="doccomment">///     // handler from an arbitrary function is unsafe because it might call a function</span>
<span class="doccomment">///     // outside the list, and there&#39;s no real way to know that at compile time with the</span>
<span class="doccomment">///     // current version of Rust. Since we&#39;re only using the write() system call here, this</span>
<span class="doccomment">///     // is safe.</span>
<span class="doccomment">///     SignalHandler::from_fn(|| {</span>
<span class="doccomment">///         println!(&quot;You pressed Ctrl-C!&quot;);</span>
<span class="doccomment">///     })</span>
<span class="doccomment">/// };</span>
<span class="doccomment">///</span>
<span class="doccomment">/// // Install our handler for the KeyboardInterrupt signal type.</span>
<span class="doccomment">/// signal::set_handler(SignalType::KeyboardInterrupt, handler)?;</span>
<span class="doccomment">/// # }</span>
<span class="doccomment">/// # Ok(()) }</span>
<span class="doccomment">/// ```</span>
<span class="attribute">#[<span class="ident">inline</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_handler</span>(<span class="ident">signal_type</span>: <span class="ident">SignalType</span>, <span class="ident">handler</span>: <span class="ident">SignalHandler</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">SetHandlerError</span><span class="op">&gt;</span> {
    <span class="kw">if</span> <span class="ident">signal_type</span>.<span class="ident">is_unsafe</span>() {
        <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">SetHandlerError::UnsafeSignal</span>);
    }

    <span class="kw">unsafe</span> { <span class="ident">set_unsafe_handler</span>(<span class="ident">signal_type</span>, <span class="ident">handler</span>) }
}
<span class="doccomment">/// Installs the specified handler for the specified unsafe signal.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Safety</span>
<span class="doccomment">/// The handler and all code that may or may not execute afterwards must be prepared for the aftermath of what might&#39;ve caused the signal.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// [`SegmentationFault`] or [`IllegalInstruction`] are most likely caused by undefined behavior invoked from Rust (the former is caused by dereferencing invalid memory, the latter is caused by dereferencing an incorrectly aligned pointer on ISAs like ARM which do not tolerate misaligned pointers), which means that the program is unsound and the only meaningful thing to do is to capture as much information as possible in a safe way — preferably using OS services to create a dump, rather than trying to read the program&#39;s global state, which might be irreversibly corrupted — and write the crash dump to some on-disk location.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Example</span>
<span class="doccomment">/// ```no_run</span>
<span class="doccomment">/// # fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span>
<span class="doccomment">/// # #[cfg(all(windows, feature = &quot;signals&quot;))] {</span>
<span class="doccomment">/// use interprocess::os::windows::signal::{self, SignalType, SignalHandler};</span>
<span class="doccomment">///</span>
<span class="doccomment">/// let handler = unsafe {</span>
<span class="doccomment">///     // Since signal handlers are restricted to a specific set of C functions, creating a</span>
<span class="doccomment">///     // handler from an arbitrary function is unsafe because it might call a function</span>
<span class="doccomment">///     // outside the list, and there&#39;s no real way to know that at compile time with the</span>
<span class="doccomment">///     // current version of Rust. Since we&#39;re only using the write() system call here, this</span>
<span class="doccomment">///     // is safe.</span>
<span class="doccomment">///     SignalHandler::from_fn(|| {</span>
<span class="doccomment">///         println!(&quot;Oh no, we&#39;re running on an i386!&quot;);</span>
<span class="doccomment">///         std::process::abort();</span>
<span class="doccomment">///     })</span>
<span class="doccomment">/// };</span>
<span class="doccomment">///</span>
<span class="doccomment">/// unsafe {</span>
<span class="doccomment">///     // Install our handler for the IllegalInstruction signal type.</span>
<span class="doccomment">///     signal::set_unsafe_handler(SignalType::IllegalInstruction, handler)?;</span>
<span class="doccomment">/// }</span>
<span class="doccomment">/// # }</span>
<span class="doccomment">/// # Ok(()) }</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// [`SegmentationFault`]: enum.SignalType.html#variant.SegmentationFault &quot; &quot;</span>
<span class="doccomment">/// [`IllegalInstruction`]: enum.SignalType.html#variant.IllegalInstruction &quot; &quot;</span>
<span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">set_unsafe_handler</span>(
    <span class="ident">signal_type</span>: <span class="ident">SignalType</span>,
    <span class="ident">handler</span>: <span class="ident">SignalHandler</span>,
) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">SetHandlerError</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">signal_type</span> <span class="op">=</span> <span class="ident">signal_type</span> <span class="kw">as</span> <span class="ident">u64</span>;
    <span class="kw">let</span> <span class="ident">handlers</span> <span class="op">=</span> <span class="ident">HANDLERS</span>.<span class="ident">upgradable_read</span>();
    <span class="kw">let</span> <span class="ident">new_signal</span> <span class="op">=</span> <span class="ident">handlers</span>.<span class="ident">get</span>(<span class="ident">signal_type</span>).<span class="ident">is_none</span>();
    <span class="kw">if</span> <span class="ident">new_signal</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">handlers</span> <span class="op">=</span> <span class="ident">RwLockUpgradableReadGuard::upgrade</span>(<span class="ident">handlers</span>);
        <span class="ident">handlers</span>.<span class="ident">remove</span>(<span class="ident">signal_type</span>);
        <span class="ident">handlers</span>.<span class="ident">insert</span>(<span class="ident">signal_type</span>, <span class="ident">handler</span>);
        <span class="ident">drop</span>(<span class="ident">handlers</span>);

        <span class="kw">let</span> <span class="ident">hook_val</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">handler</span> {
            <span class="ident">SignalHandler::Default</span> =&gt; <span class="ident">SIG_DFL</span>,
            <span class="kw">_</span> =&gt; <span class="ident">signal_receiver</span> <span class="kw">as</span> <span class="ident">usize</span>,
        };
        <span class="kw">unsafe</span> {
            <span class="comment">// SAFETY: we&#39;re using a correct value for the hook</span>
            <span class="ident">install_hook</span>(<span class="ident">signal_type</span> <span class="kw">as</span> <span class="ident">i32</span>, <span class="ident">hook_val</span>)
                .<span class="ident">map_err</span>(<span class="op">|</span><span class="kw">_</span><span class="op">|</span> <span class="ident">SetHandlerError::UnexpectedLibcCallFailure</span>)<span class="question-mark">?</span>
        }
    }
    <span class="prelude-val">Ok</span>(())
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">all</span>(<span class="ident">windows</span>, <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;signals&quot;</span>))]</span>
<span class="kw">static</span> <span class="ident">HANDLERS</span>: <span class="ident">Lazy</span><span class="op">&lt;</span><span class="ident">RwLock</span><span class="op">&lt;</span><span class="ident">IntMap</span><span class="op">&lt;</span><span class="ident">SignalHandler</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Lazy::new</span>(<span class="op">|</span><span class="op">|</span> <span class="ident">RwLock::new</span>(<span class="ident">IntMap::new</span>()));

<span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">install_hook</span>(<span class="ident">signum</span>: <span class="ident">i32</span>, <span class="ident">hook</span>: <span class="ident">usize</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), ()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">success</span> <span class="op">=</span> { <span class="ident">libc::signal</span>(<span class="ident">signum</span>, <span class="ident">hook</span>) <span class="op">!</span><span class="op">=</span> <span class="ident">libc::SIG_ERR</span> <span class="kw">as</span> <span class="kw">_</span> };
    <span class="kw">if</span> <span class="ident">success</span> {
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(())
    }
}

<span class="doccomment">/// The actual hook which is passed to `sigaction` which dispatches signals according to the global handler map (the `HANDLERS` static).</span>
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> <span class="ident">signal_receiver</span>(<span class="ident">signum</span>: <span class="ident">i32</span>) {
    <span class="kw">let</span> <span class="ident">catched</span> <span class="op">=</span> <span class="ident">panic::catch_unwind</span>(<span class="op">|</span><span class="op">|</span> {
        <span class="kw">let</span> <span class="ident">handler</span> <span class="op">=</span> {
            <span class="kw">let</span> <span class="ident">handlers</span> <span class="op">=</span> <span class="ident">HANDLERS</span>.<span class="ident">read</span>();
            <span class="kw">let</span> <span class="ident">val</span> <span class="op">=</span> <span class="ident">handlers</span>
                .<span class="ident">get</span>(<span class="ident">signum</span> <span class="kw">as</span> <span class="ident">u64</span>)
                .<span class="ident">expect</span>(<span class="string">&quot;unregistered signal passed by the OS to the shared receiver&quot;</span>);
            <span class="kw-2">*</span><span class="ident">val</span>
        };
        <span class="kw">match</span> <span class="ident">handler</span> {
            <span class="ident">SignalHandler::Ignore</span> =&gt; {}
            <span class="ident">SignalHandler::Hook</span>(<span class="ident">hook</span>) =&gt; <span class="ident">hook</span>.<span class="ident">inner</span>()(),
            <span class="ident">SignalHandler::NoReturnHook</span>(<span class="ident">hook</span>) =&gt; <span class="ident">hook</span>.<span class="ident">inner</span>()(),
            <span class="ident">SignalHandler::Default</span> =&gt; <span class="macro">unreachable!</span>(
                <span class="string">&quot;signal receiver was unregistered but has been called by the OS anyway&quot;</span>
            ),
        }
    });
    <span class="comment">// The panic hook already ran, so we only have to abort the process</span>
    <span class="ident">catched</span>.<span class="ident">unwrap_or_else</span>(<span class="op">|</span><span class="kw">_</span><span class="op">|</span> <span class="ident">process::abort</span>());
}

<span class="doccomment">/// The error produced when setting a signal handler fails.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>, <span class="ident">Hash</span>)]</span>
<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">all</span>(<span class="ident">windows</span>, <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;signals&quot;</span>), <span class="ident">derive</span>(<span class="ident">Error</span>))]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">SetHandlerError</span> {
    <span class="doccomment">/// An unsafe signal was attempted to be handled using `set_handler` instead of `set_unsafe_handler`.</span>
    <span class="attribute">#[<span class="ident">cfg_attr</span>(
        <span class="ident">all</span>(<span class="ident">windows</span>, <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;signals&quot;</span>),
        <span class="ident">error</span>(
            <span class="string">&quot;\
an unsafe signal was attempted to be handled using `set_handler` instead of `set_unsafe_handler`&quot;</span>
        )
    )]</span>
    <span class="ident">UnsafeSignal</span>,
    <span class="doccomment">/// the C library call unexpectedly failed without error information.</span>
    <span class="attribute">#[<span class="ident">cfg_attr</span>(
        <span class="ident">all</span>(<span class="ident">windows</span>, <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;signals&quot;</span>),
        <span class="ident">error</span>(<span class="string">&quot;the C library call unexpectedly failed without error information&quot;</span>)
    )]</span>
    <span class="ident">UnexpectedLibcCallFailure</span>,
}

<span class="doccomment">/// A signal handling method.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">SignalHandler</span> {
    <span class="doccomment">/// Use the default behavior specified by the C standard.</span>
    <span class="ident">Default</span>,
    <span class="doccomment">/// Ignore the signal whenever it is received.</span>
    <span class="ident">Ignore</span>,
    <span class="doccomment">/// Call a function whenever the signal is received. The function can return, execution will continue.</span>
    <span class="ident">Hook</span>(<span class="ident">SignalHook</span>),
    <span class="doccomment">/// Call a function whenever the signal is received. The function must not return.</span>
    <span class="ident">NoReturnHook</span>(<span class="ident">NoReturnSignalHook</span>),
}
<span class="kw">impl</span> <span class="ident">SignalHandler</span> {
    <span class="doccomment">/// Returns `true` for the [`Default`] variant, `false` otherwise.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`Default`]: #variant.Default.html &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">is_default</span>(<span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="macro">matches!</span>(<span class="self">self</span>, <span class="ident"><span class="self">Self</span>::Default</span>)
    }
    <span class="doccomment">/// Returns `true` for the [`Ignore`] variant, `false` otherwise.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`Ignore`]: #variant.Ignore.html &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">is_ignore</span>(<span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="macro">matches!</span>(<span class="self">self</span>, <span class="ident"><span class="self">Self</span>::Ignore</span>)
    }
    <span class="doccomment">/// Returns `true` for the [`Hook`] and [`NoReturnHook`] variants, `false` otherwise.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`Hook`]: #variant.Hook.html &quot; &quot;</span>
    <span class="doccomment">/// [`NoReturnHook`]: #variant.NoReturnHook.html &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">is_hook</span>(<span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="macro">matches!</span>(<span class="self">self</span>, <span class="ident"><span class="self">Self</span>::Hook</span>(..))
    }
    <span class="doccomment">/// Creates a handler which calls the specified function.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Safety</span>
    <span class="doccomment">/// The function must not call any C functions which are not considered signal-safe. See the [module-level section on signal-safe C functions] for more.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [module-level section on signal-safe C functions]: index.html#signal-safe-c-functions &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">from_fn</span>(<span class="ident">function</span>: <span class="kw">fn</span>()) -&gt; <span class="self">Self</span> {
        <span class="ident"><span class="self">Self</span>::Hook</span>(<span class="ident">SignalHook::from_fn</span>(<span class="ident">function</span>))
    }
    <span class="doccomment">/// Creates a handler which calls the specified function and is known to never return.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Safety</span>
    <span class="doccomment">/// The function must not call any C functions which are not considered signal-safe. See the [module-level section on signal-safe C functions] for more.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [module-level section on signal-safe C functions]: index.html#signal-safe-c-functions &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">from_fn_noreturn</span>(<span class="ident">function</span>: <span class="kw">fn</span>() -&gt; <span class="op">!</span>) -&gt; <span class="self">Self</span> {
        <span class="ident"><span class="self">Self</span>::NoReturnHook</span>(<span class="ident">NoReturnSignalHook::from_fn</span>(<span class="ident">function</span>))
    }
}
<span class="kw">impl</span> <span class="ident">Default</span> <span class="kw">for</span> <span class="ident">SignalHandler</span> {
    <span class="doccomment">/// Returns [`SignalHandler::Default`].</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`SignalHandler::Default`]: #variant.Default &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">default</span>() -&gt; <span class="self">Self</span> {
        <span class="ident"><span class="self">Self</span>::Default</span>
    }
}

<span class="doccomment">/// A function which can be used as a signal handler.</span>
<span class="attribute">#[<span class="ident">repr</span>(<span class="ident">transparent</span>)]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">SignalHook</span>(<span class="kw">fn</span>());
<span class="kw">impl</span> <span class="ident">SignalHook</span> {
    <span class="doccomment">/// Creates a hook which calls the specified function.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Safety</span>
    <span class="doccomment">/// The function must not call any C functions which are not considered signal-safe. See the [module-level section on signal-safe functions] for more.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [module-level section on signal-safe functions]: index.html#signal-safe-functions &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">from_fn</span>(<span class="ident">function</span>: <span class="kw">fn</span>()) -&gt; <span class="self">Self</span> {
        <span class="self">Self</span>(<span class="ident">function</span>)
    }
    <span class="doccomment">/// Returns the wrapped function.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">inner</span>(<span class="self">self</span>) -&gt; <span class="kw">fn</span>() {
        <span class="self">self</span>.<span class="number">0</span>
    }
}
<span class="kw">impl</span> <span class="ident">From</span><span class="op">&lt;</span><span class="ident">SignalHook</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="kw">fn</span>() {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">op</span>: <span class="ident">SignalHook</span>) -&gt; <span class="self">Self</span> {
        <span class="ident">op</span>.<span class="number">0</span>
    }
}

<span class="doccomment">/// A function which can be used as a signal handler, but one which also never returns.</span>
<span class="attribute">#[<span class="ident">repr</span>(<span class="ident">transparent</span>)]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">NoReturnSignalHook</span>(<span class="kw">fn</span>() -&gt; <span class="op">!</span>);
<span class="kw">impl</span> <span class="ident">NoReturnSignalHook</span> {
    <span class="doccomment">/// Creates a hook which calls the specified function.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Safety</span>
    <span class="doccomment">/// Same as for the normal [`SignalHook`].</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`SignalHook`]: struct.SignalHook.html &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">from_fn</span>(<span class="ident">function</span>: <span class="kw">fn</span>() -&gt; <span class="op">!</span>) -&gt; <span class="self">Self</span> {
        <span class="self">Self</span>(<span class="ident">function</span>)
    }
    <span class="doccomment">/// Returns the wrapped function.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">inner</span>(<span class="self">self</span>) -&gt; <span class="kw">fn</span>() -&gt; <span class="op">!</span> {
        <span class="self">self</span>.<span class="number">0</span>
    }
}
<span class="kw">impl</span> <span class="ident">From</span><span class="op">&lt;</span><span class="ident">NoReturnSignalHook</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="kw">fn</span>() -&gt; <span class="op">!</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">op</span>: <span class="ident">NoReturnSignalHook</span>) -&gt; <span class="self">Self</span> {
        <span class="ident">op</span>.<span class="number">0</span>
    }
}

<span class="doccomment">/// All standard signal types as defined in the C standard.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The values can be safely and quickly converted to [`i32`]/[`u32`]. The reverse process involves safety checks, making sure that unknown signal values are never stored.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// [`i32`]: https://doc.rust-lang.org/std/primitive.i32.html &quot; &quot;</span>
<span class="doccomment">/// [`u32`]: https://doc.rust-lang.org/std/primitive.u32.html &quot; &quot;</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>, <span class="ident">Hash</span>)]</span>
<span class="attribute">#[<span class="ident">repr</span>(<span class="ident">i32</span>)]</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">SignalType</span> {
    <span class="doccomment">/// `SIGINT` — keyboard interrupt, usually sent by pressing `Ctrl`+`C` by the terminal. This signal is typically set to be ignored if the program runs an interactive interface: GUI/TUI, interactive shell (the Python shell, for example) or any other kind of interface which runs in a loop, as opposed to a command-line invocation of the program which reads its standard input or command-line arguments, performs a task and exits. If the interactive interface is running a lengthy operation, a good idea is to temporarily re-enable the signal and abort the lengthy operation if the signal is received, then disable it again.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination.*</span>
    <span class="ident">KeyboardInterrupt</span> <span class="op">=</span> <span class="ident">SIGINT</span>,
    <span class="doccomment">/// `SIGILL` — illegal or malformed instruction exception, generated by the CPU whenever such an instruction is executed. This signal normally should not be overriden or masked out, since it likely means that the executable file or the memory of the process has been corrupted and further execution is a risk of invoking negative consequences.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// For reasons described above, **this signal is considered unsafe** — handling it requires using `set_unsafe_handler`. **Signal hooks for this signal are also required to never return** — those must be wrapped into a `NoReturnSignalHook`.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination with a core dump.*</span>
    <span class="ident">IllegalInstruction</span> <span class="op">=</span> <span class="ident">SIGILL</span>,
    <span class="doccomment">/// `SIGABRT` — abnormal termination requested. This signal is typically invoked by the program itself, using [`std::process::abort`] or the equivalent C function; still, like any other signal, it can be sent from outside the process.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination with a core dump.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`std::process::abort`]: https://doc.rust-lang.org/std/process/fn.abort.html &quot; &quot;</span>
    <span class="ident">Abort</span> <span class="op">=</span> <span class="ident">SIGABRT</span>,
    <span class="doccomment">/// `SIGFPE` — mathematical exception. This signal is generated whenever an undefined mathematical operation is performed — mainly integer division by zero.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// **Signal hooks for this signal are required to never return** — those must be wrapped into a `NoReturnSignalHook`.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination with a core dump.*</span>
    <span class="ident">MathException</span> <span class="op">=</span> <span class="ident">SIGFPE</span>,
    <span class="doccomment">/// `SIGSEGV` — invaid memory access. This signal is issued by the OS whenever the program tries to access an invalid memory location, such as the `NULL` pointer or simply an address outside the user-mode address space as established by the OS. The only case when this signal can be received by a Rust program is if memory unsafety occurs due to misuse of unsafe code. As such, it should normally not be masked out or handled, as it likely indicates a critical bug (soundness hole), executable file corruption or process memory corruption.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// For reasons described above, **this signal is considered unsafe** — handling it requires using `set_unsafe_handler`. **Signal hooks for this signal are also required to never return** — those must be wrapped into a `NoReturnSignalHook`.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination with a core dump.*</span>
    <span class="ident">SegmentationFault</span> <span class="op">=</span> <span class="ident">SIGSEGV</span>,
    <span class="doccomment">/// `SIGTERM` — request for termination. This signal can only be sent using the usual signal sending procedures. Unlike [`KeyboardInterrupt`], this signal is not a request to break out of a lengthy operation, but rather to close the program as a whole. Signal handlers for this signal are expected to perform minimal cleanup and quick state save procedures and then exit.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`KeyboardInterrupt`]: #variant.KeyboardInterrupt &quot; &quot;</span>
    <span class="ident">Termination</span> <span class="op">=</span> <span class="ident">SIGTERM</span>,
}
<span class="kw">impl</span> <span class="ident">SignalType</span> {
    <span class="doccomment">/// Returns `true` if the value is a signal which requires its custom handler functions to never return, `false` otherwise.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">requires_diverging_hook</span>(<span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="macro">matches!</span>(
            <span class="self">self</span>,
            <span class="ident"><span class="self">Self</span>::SegmentationFault</span> <span class="op">|</span> <span class="ident"><span class="self">Self</span>::IllegalInstruction</span> <span class="op">|</span> <span class="ident"><span class="self">Self</span>::MathException</span>
        )
    }
    <span class="doccomment">/// Returns `true` if the value is an unsafe signal which requires unsafe code when setting a handling method, `false` otherwise.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">is_unsafe</span>(<span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="macro">matches!</span>(<span class="self">self</span>, <span class="ident"><span class="self">Self</span>::SegmentationFault</span> <span class="op">|</span> <span class="ident"><span class="self">Self</span>::IllegalInstruction</span>)
    }
}
<span class="kw">impl</span> <span class="ident">From</span><span class="op">&lt;</span><span class="ident">SignalType</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">i32</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">op</span>: <span class="ident">SignalType</span>) -&gt; <span class="self">Self</span> {
        <span class="ident">op</span> <span class="kw">as</span> <span class="ident">i32</span>
    }
}
<span class="kw">impl</span> <span class="ident">From</span><span class="op">&lt;</span><span class="ident">SignalType</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">u32</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">op</span>: <span class="ident">SignalType</span>) -&gt; <span class="self">Self</span> {
        <span class="ident">op</span> <span class="kw">as</span> <span class="ident">u32</span>
    }
}
<span class="kw">impl</span> <span class="ident">TryFrom</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">SignalType</span> {
    <span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="ident">UnknownSignalError</span>;
    <span class="kw">fn</span> <span class="ident">try_from</span>(<span class="ident">value</span>: <span class="ident">i32</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>, <span class="ident"><span class="self">Self</span>::Error</span><span class="op">&gt;</span> {
        <span class="kw">match</span> <span class="ident">value</span> {
            <span class="ident">SIGINT</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::KeyboardInterrupt</span>),
            <span class="ident">SIGILL</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::IllegalInstruction</span>),
            <span class="ident">SIGABRT</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::Abort</span>),
            <span class="ident">SIGFPE</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::MathException</span>),
            <span class="ident">SIGSEGV</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::SegmentationFault</span>),
            <span class="ident">SIGTERM</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::Termination</span>),
            <span class="kw">_</span> =&gt; <span class="prelude-val">Err</span>(<span class="ident">UnknownSignalError</span> { <span class="ident">value</span> }),
        }
    }
}
<span class="kw">impl</span> <span class="ident">TryFrom</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">SignalType</span> {
    <span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="ident">UnknownSignalError</span>;
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">try_from</span>(<span class="ident">value</span>: <span class="ident">u32</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>, <span class="ident"><span class="self">Self</span>::Error</span><span class="op">&gt;</span> {
        (<span class="ident">value</span> <span class="kw">as</span> <span class="ident">u32</span>).<span class="ident">try_into</span>()
    }
}
<span class="doccomment">/// Error type returned when a conversion from [`i32`]/[`u32`] to [`SignalType`] fails.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// [`i32`]: https://doc.rust-lang.org/std/primitive.i32.html &quot; &quot;</span>
<span class="doccomment">/// [`u32`]: https://doc.rust-lang.org/std/primitive.u32.html &quot; &quot;</span>
<span class="doccomment">/// [`SignalType`]: enum.SignalType.html &quot; &quot;</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UnknownSignalError</span> {
    <span class="doccomment">/// The unknown signal value which was encountered.</span>
    <span class="kw">pub</span> <span class="ident">value</span>: <span class="ident">i32</span>,
}
<span class="kw">impl</span> <span class="ident">fmt::Display</span> <span class="kw">for</span> <span class="ident">UnknownSignalError</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) -&gt; <span class="ident">fmt::Result</span> {
        <span class="macro">write!</span>(<span class="ident">f</span>, <span class="string">&quot;unknown signal value {}&quot;</span>, <span class="self">self</span>.<span class="ident">value</span>)
    }
}
<span class="kw">impl</span> <span class="ident">fmt::Binary</span> <span class="kw">for</span> <span class="ident">UnknownSignalError</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) -&gt; <span class="ident">fmt::Result</span> {
        <span class="macro">write!</span>(<span class="ident">f</span>, <span class="string">&quot;unknown signal value {:b}&quot;</span>, <span class="self">self</span>.<span class="ident">value</span>)
    }
}
<span class="kw">impl</span> <span class="ident">fmt::LowerHex</span> <span class="kw">for</span> <span class="ident">UnknownSignalError</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) -&gt; <span class="ident">fmt::Result</span> {
        <span class="macro">write!</span>(<span class="ident">f</span>, <span class="string">&quot;unknown signal value {:x}&quot;</span>, <span class="self">self</span>.<span class="ident">value</span>)
    }
}
<span class="kw">impl</span> <span class="ident">fmt::UpperExp</span> <span class="kw">for</span> <span class="ident">UnknownSignalError</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) -&gt; <span class="ident">fmt::Result</span> {
        <span class="macro">write!</span>(<span class="ident">f</span>, <span class="string">&quot;unknown signal value {:X}&quot;</span>, <span class="self">self</span>.<span class="ident">value</span>)
    }
}
<span class="kw">impl</span> <span class="ident">fmt::Octal</span> <span class="kw">for</span> <span class="ident">UnknownSignalError</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) -&gt; <span class="ident">fmt::Result</span> {
        <span class="macro">write!</span>(<span class="ident">f</span>, <span class="string">&quot;unknown signal value {:o}&quot;</span>, <span class="self">self</span>.<span class="ident">value</span>)
    }
}
<span class="kw">impl</span> <span class="ident">Error</span> <span class="kw">for</span> <span class="ident">UnknownSignalError</span> {}
</code></pre></div>
</section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../../../" data-current-crate="interprocess" data-search-index-js="../../../../search-index.js" data-search-js="../../../../search.js"></div>
    <script src="../../../../main.js"></script><script src="../../../../source-script.js"></script><script src="../../../../source-files.js"></script>
</body></html>