<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `&#x2F;home&#x2F;runner&#x2F;.cargo&#x2F;registry&#x2F;src&#x2F;github.com-1ecc6299db9ec823&#x2F;interprocess-1.1.1&#x2F;src&#x2F;os&#x2F;unix&#x2F;signal.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>signal.rs - source</title><link rel="stylesheet" type="text/css" href="../../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../../../storage.js"></script><script src="../../../../crates.js"></script><noscript><link rel="stylesheet" href="../../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../../interprocess/index.html'><div class='logo-container rust-logo'><img src='../../../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../../../wheel.svg"></a></div></form></nav><section id="main" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">   1</span>
<span id="2">   2</span>
<span id="3">   3</span>
<span id="4">   4</span>
<span id="5">   5</span>
<span id="6">   6</span>
<span id="7">   7</span>
<span id="8">   8</span>
<span id="9">   9</span>
<span id="10">  10</span>
<span id="11">  11</span>
<span id="12">  12</span>
<span id="13">  13</span>
<span id="14">  14</span>
<span id="15">  15</span>
<span id="16">  16</span>
<span id="17">  17</span>
<span id="18">  18</span>
<span id="19">  19</span>
<span id="20">  20</span>
<span id="21">  21</span>
<span id="22">  22</span>
<span id="23">  23</span>
<span id="24">  24</span>
<span id="25">  25</span>
<span id="26">  26</span>
<span id="27">  27</span>
<span id="28">  28</span>
<span id="29">  29</span>
<span id="30">  30</span>
<span id="31">  31</span>
<span id="32">  32</span>
<span id="33">  33</span>
<span id="34">  34</span>
<span id="35">  35</span>
<span id="36">  36</span>
<span id="37">  37</span>
<span id="38">  38</span>
<span id="39">  39</span>
<span id="40">  40</span>
<span id="41">  41</span>
<span id="42">  42</span>
<span id="43">  43</span>
<span id="44">  44</span>
<span id="45">  45</span>
<span id="46">  46</span>
<span id="47">  47</span>
<span id="48">  48</span>
<span id="49">  49</span>
<span id="50">  50</span>
<span id="51">  51</span>
<span id="52">  52</span>
<span id="53">  53</span>
<span id="54">  54</span>
<span id="55">  55</span>
<span id="56">  56</span>
<span id="57">  57</span>
<span id="58">  58</span>
<span id="59">  59</span>
<span id="60">  60</span>
<span id="61">  61</span>
<span id="62">  62</span>
<span id="63">  63</span>
<span id="64">  64</span>
<span id="65">  65</span>
<span id="66">  66</span>
<span id="67">  67</span>
<span id="68">  68</span>
<span id="69">  69</span>
<span id="70">  70</span>
<span id="71">  71</span>
<span id="72">  72</span>
<span id="73">  73</span>
<span id="74">  74</span>
<span id="75">  75</span>
<span id="76">  76</span>
<span id="77">  77</span>
<span id="78">  78</span>
<span id="79">  79</span>
<span id="80">  80</span>
<span id="81">  81</span>
<span id="82">  82</span>
<span id="83">  83</span>
<span id="84">  84</span>
<span id="85">  85</span>
<span id="86">  86</span>
<span id="87">  87</span>
<span id="88">  88</span>
<span id="89">  89</span>
<span id="90">  90</span>
<span id="91">  91</span>
<span id="92">  92</span>
<span id="93">  93</span>
<span id="94">  94</span>
<span id="95">  95</span>
<span id="96">  96</span>
<span id="97">  97</span>
<span id="98">  98</span>
<span id="99">  99</span>
<span id="100"> 100</span>
<span id="101"> 101</span>
<span id="102"> 102</span>
<span id="103"> 103</span>
<span id="104"> 104</span>
<span id="105"> 105</span>
<span id="106"> 106</span>
<span id="107"> 107</span>
<span id="108"> 108</span>
<span id="109"> 109</span>
<span id="110"> 110</span>
<span id="111"> 111</span>
<span id="112"> 112</span>
<span id="113"> 113</span>
<span id="114"> 114</span>
<span id="115"> 115</span>
<span id="116"> 116</span>
<span id="117"> 117</span>
<span id="118"> 118</span>
<span id="119"> 119</span>
<span id="120"> 120</span>
<span id="121"> 121</span>
<span id="122"> 122</span>
<span id="123"> 123</span>
<span id="124"> 124</span>
<span id="125"> 125</span>
<span id="126"> 126</span>
<span id="127"> 127</span>
<span id="128"> 128</span>
<span id="129"> 129</span>
<span id="130"> 130</span>
<span id="131"> 131</span>
<span id="132"> 132</span>
<span id="133"> 133</span>
<span id="134"> 134</span>
<span id="135"> 135</span>
<span id="136"> 136</span>
<span id="137"> 137</span>
<span id="138"> 138</span>
<span id="139"> 139</span>
<span id="140"> 140</span>
<span id="141"> 141</span>
<span id="142"> 142</span>
<span id="143"> 143</span>
<span id="144"> 144</span>
<span id="145"> 145</span>
<span id="146"> 146</span>
<span id="147"> 147</span>
<span id="148"> 148</span>
<span id="149"> 149</span>
<span id="150"> 150</span>
<span id="151"> 151</span>
<span id="152"> 152</span>
<span id="153"> 153</span>
<span id="154"> 154</span>
<span id="155"> 155</span>
<span id="156"> 156</span>
<span id="157"> 157</span>
<span id="158"> 158</span>
<span id="159"> 159</span>
<span id="160"> 160</span>
<span id="161"> 161</span>
<span id="162"> 162</span>
<span id="163"> 163</span>
<span id="164"> 164</span>
<span id="165"> 165</span>
<span id="166"> 166</span>
<span id="167"> 167</span>
<span id="168"> 168</span>
<span id="169"> 169</span>
<span id="170"> 170</span>
<span id="171"> 171</span>
<span id="172"> 172</span>
<span id="173"> 173</span>
<span id="174"> 174</span>
<span id="175"> 175</span>
<span id="176"> 176</span>
<span id="177"> 177</span>
<span id="178"> 178</span>
<span id="179"> 179</span>
<span id="180"> 180</span>
<span id="181"> 181</span>
<span id="182"> 182</span>
<span id="183"> 183</span>
<span id="184"> 184</span>
<span id="185"> 185</span>
<span id="186"> 186</span>
<span id="187"> 187</span>
<span id="188"> 188</span>
<span id="189"> 189</span>
<span id="190"> 190</span>
<span id="191"> 191</span>
<span id="192"> 192</span>
<span id="193"> 193</span>
<span id="194"> 194</span>
<span id="195"> 195</span>
<span id="196"> 196</span>
<span id="197"> 197</span>
<span id="198"> 198</span>
<span id="199"> 199</span>
<span id="200"> 200</span>
<span id="201"> 201</span>
<span id="202"> 202</span>
<span id="203"> 203</span>
<span id="204"> 204</span>
<span id="205"> 205</span>
<span id="206"> 206</span>
<span id="207"> 207</span>
<span id="208"> 208</span>
<span id="209"> 209</span>
<span id="210"> 210</span>
<span id="211"> 211</span>
<span id="212"> 212</span>
<span id="213"> 213</span>
<span id="214"> 214</span>
<span id="215"> 215</span>
<span id="216"> 216</span>
<span id="217"> 217</span>
<span id="218"> 218</span>
<span id="219"> 219</span>
<span id="220"> 220</span>
<span id="221"> 221</span>
<span id="222"> 222</span>
<span id="223"> 223</span>
<span id="224"> 224</span>
<span id="225"> 225</span>
<span id="226"> 226</span>
<span id="227"> 227</span>
<span id="228"> 228</span>
<span id="229"> 229</span>
<span id="230"> 230</span>
<span id="231"> 231</span>
<span id="232"> 232</span>
<span id="233"> 233</span>
<span id="234"> 234</span>
<span id="235"> 235</span>
<span id="236"> 236</span>
<span id="237"> 237</span>
<span id="238"> 238</span>
<span id="239"> 239</span>
<span id="240"> 240</span>
<span id="241"> 241</span>
<span id="242"> 242</span>
<span id="243"> 243</span>
<span id="244"> 244</span>
<span id="245"> 245</span>
<span id="246"> 246</span>
<span id="247"> 247</span>
<span id="248"> 248</span>
<span id="249"> 249</span>
<span id="250"> 250</span>
<span id="251"> 251</span>
<span id="252"> 252</span>
<span id="253"> 253</span>
<span id="254"> 254</span>
<span id="255"> 255</span>
<span id="256"> 256</span>
<span id="257"> 257</span>
<span id="258"> 258</span>
<span id="259"> 259</span>
<span id="260"> 260</span>
<span id="261"> 261</span>
<span id="262"> 262</span>
<span id="263"> 263</span>
<span id="264"> 264</span>
<span id="265"> 265</span>
<span id="266"> 266</span>
<span id="267"> 267</span>
<span id="268"> 268</span>
<span id="269"> 269</span>
<span id="270"> 270</span>
<span id="271"> 271</span>
<span id="272"> 272</span>
<span id="273"> 273</span>
<span id="274"> 274</span>
<span id="275"> 275</span>
<span id="276"> 276</span>
<span id="277"> 277</span>
<span id="278"> 278</span>
<span id="279"> 279</span>
<span id="280"> 280</span>
<span id="281"> 281</span>
<span id="282"> 282</span>
<span id="283"> 283</span>
<span id="284"> 284</span>
<span id="285"> 285</span>
<span id="286"> 286</span>
<span id="287"> 287</span>
<span id="288"> 288</span>
<span id="289"> 289</span>
<span id="290"> 290</span>
<span id="291"> 291</span>
<span id="292"> 292</span>
<span id="293"> 293</span>
<span id="294"> 294</span>
<span id="295"> 295</span>
<span id="296"> 296</span>
<span id="297"> 297</span>
<span id="298"> 298</span>
<span id="299"> 299</span>
<span id="300"> 300</span>
<span id="301"> 301</span>
<span id="302"> 302</span>
<span id="303"> 303</span>
<span id="304"> 304</span>
<span id="305"> 305</span>
<span id="306"> 306</span>
<span id="307"> 307</span>
<span id="308"> 308</span>
<span id="309"> 309</span>
<span id="310"> 310</span>
<span id="311"> 311</span>
<span id="312"> 312</span>
<span id="313"> 313</span>
<span id="314"> 314</span>
<span id="315"> 315</span>
<span id="316"> 316</span>
<span id="317"> 317</span>
<span id="318"> 318</span>
<span id="319"> 319</span>
<span id="320"> 320</span>
<span id="321"> 321</span>
<span id="322"> 322</span>
<span id="323"> 323</span>
<span id="324"> 324</span>
<span id="325"> 325</span>
<span id="326"> 326</span>
<span id="327"> 327</span>
<span id="328"> 328</span>
<span id="329"> 329</span>
<span id="330"> 330</span>
<span id="331"> 331</span>
<span id="332"> 332</span>
<span id="333"> 333</span>
<span id="334"> 334</span>
<span id="335"> 335</span>
<span id="336"> 336</span>
<span id="337"> 337</span>
<span id="338"> 338</span>
<span id="339"> 339</span>
<span id="340"> 340</span>
<span id="341"> 341</span>
<span id="342"> 342</span>
<span id="343"> 343</span>
<span id="344"> 344</span>
<span id="345"> 345</span>
<span id="346"> 346</span>
<span id="347"> 347</span>
<span id="348"> 348</span>
<span id="349"> 349</span>
<span id="350"> 350</span>
<span id="351"> 351</span>
<span id="352"> 352</span>
<span id="353"> 353</span>
<span id="354"> 354</span>
<span id="355"> 355</span>
<span id="356"> 356</span>
<span id="357"> 357</span>
<span id="358"> 358</span>
<span id="359"> 359</span>
<span id="360"> 360</span>
<span id="361"> 361</span>
<span id="362"> 362</span>
<span id="363"> 363</span>
<span id="364"> 364</span>
<span id="365"> 365</span>
<span id="366"> 366</span>
<span id="367"> 367</span>
<span id="368"> 368</span>
<span id="369"> 369</span>
<span id="370"> 370</span>
<span id="371"> 371</span>
<span id="372"> 372</span>
<span id="373"> 373</span>
<span id="374"> 374</span>
<span id="375"> 375</span>
<span id="376"> 376</span>
<span id="377"> 377</span>
<span id="378"> 378</span>
<span id="379"> 379</span>
<span id="380"> 380</span>
<span id="381"> 381</span>
<span id="382"> 382</span>
<span id="383"> 383</span>
<span id="384"> 384</span>
<span id="385"> 385</span>
<span id="386"> 386</span>
<span id="387"> 387</span>
<span id="388"> 388</span>
<span id="389"> 389</span>
<span id="390"> 390</span>
<span id="391"> 391</span>
<span id="392"> 392</span>
<span id="393"> 393</span>
<span id="394"> 394</span>
<span id="395"> 395</span>
<span id="396"> 396</span>
<span id="397"> 397</span>
<span id="398"> 398</span>
<span id="399"> 399</span>
<span id="400"> 400</span>
<span id="401"> 401</span>
<span id="402"> 402</span>
<span id="403"> 403</span>
<span id="404"> 404</span>
<span id="405"> 405</span>
<span id="406"> 406</span>
<span id="407"> 407</span>
<span id="408"> 408</span>
<span id="409"> 409</span>
<span id="410"> 410</span>
<span id="411"> 411</span>
<span id="412"> 412</span>
<span id="413"> 413</span>
<span id="414"> 414</span>
<span id="415"> 415</span>
<span id="416"> 416</span>
<span id="417"> 417</span>
<span id="418"> 418</span>
<span id="419"> 419</span>
<span id="420"> 420</span>
<span id="421"> 421</span>
<span id="422"> 422</span>
<span id="423"> 423</span>
<span id="424"> 424</span>
<span id="425"> 425</span>
<span id="426"> 426</span>
<span id="427"> 427</span>
<span id="428"> 428</span>
<span id="429"> 429</span>
<span id="430"> 430</span>
<span id="431"> 431</span>
<span id="432"> 432</span>
<span id="433"> 433</span>
<span id="434"> 434</span>
<span id="435"> 435</span>
<span id="436"> 436</span>
<span id="437"> 437</span>
<span id="438"> 438</span>
<span id="439"> 439</span>
<span id="440"> 440</span>
<span id="441"> 441</span>
<span id="442"> 442</span>
<span id="443"> 443</span>
<span id="444"> 444</span>
<span id="445"> 445</span>
<span id="446"> 446</span>
<span id="447"> 447</span>
<span id="448"> 448</span>
<span id="449"> 449</span>
<span id="450"> 450</span>
<span id="451"> 451</span>
<span id="452"> 452</span>
<span id="453"> 453</span>
<span id="454"> 454</span>
<span id="455"> 455</span>
<span id="456"> 456</span>
<span id="457"> 457</span>
<span id="458"> 458</span>
<span id="459"> 459</span>
<span id="460"> 460</span>
<span id="461"> 461</span>
<span id="462"> 462</span>
<span id="463"> 463</span>
<span id="464"> 464</span>
<span id="465"> 465</span>
<span id="466"> 466</span>
<span id="467"> 467</span>
<span id="468"> 468</span>
<span id="469"> 469</span>
<span id="470"> 470</span>
<span id="471"> 471</span>
<span id="472"> 472</span>
<span id="473"> 473</span>
<span id="474"> 474</span>
<span id="475"> 475</span>
<span id="476"> 476</span>
<span id="477"> 477</span>
<span id="478"> 478</span>
<span id="479"> 479</span>
<span id="480"> 480</span>
<span id="481"> 481</span>
<span id="482"> 482</span>
<span id="483"> 483</span>
<span id="484"> 484</span>
<span id="485"> 485</span>
<span id="486"> 486</span>
<span id="487"> 487</span>
<span id="488"> 488</span>
<span id="489"> 489</span>
<span id="490"> 490</span>
<span id="491"> 491</span>
<span id="492"> 492</span>
<span id="493"> 493</span>
<span id="494"> 494</span>
<span id="495"> 495</span>
<span id="496"> 496</span>
<span id="497"> 497</span>
<span id="498"> 498</span>
<span id="499"> 499</span>
<span id="500"> 500</span>
<span id="501"> 501</span>
<span id="502"> 502</span>
<span id="503"> 503</span>
<span id="504"> 504</span>
<span id="505"> 505</span>
<span id="506"> 506</span>
<span id="507"> 507</span>
<span id="508"> 508</span>
<span id="509"> 509</span>
<span id="510"> 510</span>
<span id="511"> 511</span>
<span id="512"> 512</span>
<span id="513"> 513</span>
<span id="514"> 514</span>
<span id="515"> 515</span>
<span id="516"> 516</span>
<span id="517"> 517</span>
<span id="518"> 518</span>
<span id="519"> 519</span>
<span id="520"> 520</span>
<span id="521"> 521</span>
<span id="522"> 522</span>
<span id="523"> 523</span>
<span id="524"> 524</span>
<span id="525"> 525</span>
<span id="526"> 526</span>
<span id="527"> 527</span>
<span id="528"> 528</span>
<span id="529"> 529</span>
<span id="530"> 530</span>
<span id="531"> 531</span>
<span id="532"> 532</span>
<span id="533"> 533</span>
<span id="534"> 534</span>
<span id="535"> 535</span>
<span id="536"> 536</span>
<span id="537"> 537</span>
<span id="538"> 538</span>
<span id="539"> 539</span>
<span id="540"> 540</span>
<span id="541"> 541</span>
<span id="542"> 542</span>
<span id="543"> 543</span>
<span id="544"> 544</span>
<span id="545"> 545</span>
<span id="546"> 546</span>
<span id="547"> 547</span>
<span id="548"> 548</span>
<span id="549"> 549</span>
<span id="550"> 550</span>
<span id="551"> 551</span>
<span id="552"> 552</span>
<span id="553"> 553</span>
<span id="554"> 554</span>
<span id="555"> 555</span>
<span id="556"> 556</span>
<span id="557"> 557</span>
<span id="558"> 558</span>
<span id="559"> 559</span>
<span id="560"> 560</span>
<span id="561"> 561</span>
<span id="562"> 562</span>
<span id="563"> 563</span>
<span id="564"> 564</span>
<span id="565"> 565</span>
<span id="566"> 566</span>
<span id="567"> 567</span>
<span id="568"> 568</span>
<span id="569"> 569</span>
<span id="570"> 570</span>
<span id="571"> 571</span>
<span id="572"> 572</span>
<span id="573"> 573</span>
<span id="574"> 574</span>
<span id="575"> 575</span>
<span id="576"> 576</span>
<span id="577"> 577</span>
<span id="578"> 578</span>
<span id="579"> 579</span>
<span id="580"> 580</span>
<span id="581"> 581</span>
<span id="582"> 582</span>
<span id="583"> 583</span>
<span id="584"> 584</span>
<span id="585"> 585</span>
<span id="586"> 586</span>
<span id="587"> 587</span>
<span id="588"> 588</span>
<span id="589"> 589</span>
<span id="590"> 590</span>
<span id="591"> 591</span>
<span id="592"> 592</span>
<span id="593"> 593</span>
<span id="594"> 594</span>
<span id="595"> 595</span>
<span id="596"> 596</span>
<span id="597"> 597</span>
<span id="598"> 598</span>
<span id="599"> 599</span>
<span id="600"> 600</span>
<span id="601"> 601</span>
<span id="602"> 602</span>
<span id="603"> 603</span>
<span id="604"> 604</span>
<span id="605"> 605</span>
<span id="606"> 606</span>
<span id="607"> 607</span>
<span id="608"> 608</span>
<span id="609"> 609</span>
<span id="610"> 610</span>
<span id="611"> 611</span>
<span id="612"> 612</span>
<span id="613"> 613</span>
<span id="614"> 614</span>
<span id="615"> 615</span>
<span id="616"> 616</span>
<span id="617"> 617</span>
<span id="618"> 618</span>
<span id="619"> 619</span>
<span id="620"> 620</span>
<span id="621"> 621</span>
<span id="622"> 622</span>
<span id="623"> 623</span>
<span id="624"> 624</span>
<span id="625"> 625</span>
<span id="626"> 626</span>
<span id="627"> 627</span>
<span id="628"> 628</span>
<span id="629"> 629</span>
<span id="630"> 630</span>
<span id="631"> 631</span>
<span id="632"> 632</span>
<span id="633"> 633</span>
<span id="634"> 634</span>
<span id="635"> 635</span>
<span id="636"> 636</span>
<span id="637"> 637</span>
<span id="638"> 638</span>
<span id="639"> 639</span>
<span id="640"> 640</span>
<span id="641"> 641</span>
<span id="642"> 642</span>
<span id="643"> 643</span>
<span id="644"> 644</span>
<span id="645"> 645</span>
<span id="646"> 646</span>
<span id="647"> 647</span>
<span id="648"> 648</span>
<span id="649"> 649</span>
<span id="650"> 650</span>
<span id="651"> 651</span>
<span id="652"> 652</span>
<span id="653"> 653</span>
<span id="654"> 654</span>
<span id="655"> 655</span>
<span id="656"> 656</span>
<span id="657"> 657</span>
<span id="658"> 658</span>
<span id="659"> 659</span>
<span id="660"> 660</span>
<span id="661"> 661</span>
<span id="662"> 662</span>
<span id="663"> 663</span>
<span id="664"> 664</span>
<span id="665"> 665</span>
<span id="666"> 666</span>
<span id="667"> 667</span>
<span id="668"> 668</span>
<span id="669"> 669</span>
<span id="670"> 670</span>
<span id="671"> 671</span>
<span id="672"> 672</span>
<span id="673"> 673</span>
<span id="674"> 674</span>
<span id="675"> 675</span>
<span id="676"> 676</span>
<span id="677"> 677</span>
<span id="678"> 678</span>
<span id="679"> 679</span>
<span id="680"> 680</span>
<span id="681"> 681</span>
<span id="682"> 682</span>
<span id="683"> 683</span>
<span id="684"> 684</span>
<span id="685"> 685</span>
<span id="686"> 686</span>
<span id="687"> 687</span>
<span id="688"> 688</span>
<span id="689"> 689</span>
<span id="690"> 690</span>
<span id="691"> 691</span>
<span id="692"> 692</span>
<span id="693"> 693</span>
<span id="694"> 694</span>
<span id="695"> 695</span>
<span id="696"> 696</span>
<span id="697"> 697</span>
<span id="698"> 698</span>
<span id="699"> 699</span>
<span id="700"> 700</span>
<span id="701"> 701</span>
<span id="702"> 702</span>
<span id="703"> 703</span>
<span id="704"> 704</span>
<span id="705"> 705</span>
<span id="706"> 706</span>
<span id="707"> 707</span>
<span id="708"> 708</span>
<span id="709"> 709</span>
<span id="710"> 710</span>
<span id="711"> 711</span>
<span id="712"> 712</span>
<span id="713"> 713</span>
<span id="714"> 714</span>
<span id="715"> 715</span>
<span id="716"> 716</span>
<span id="717"> 717</span>
<span id="718"> 718</span>
<span id="719"> 719</span>
<span id="720"> 720</span>
<span id="721"> 721</span>
<span id="722"> 722</span>
<span id="723"> 723</span>
<span id="724"> 724</span>
<span id="725"> 725</span>
<span id="726"> 726</span>
<span id="727"> 727</span>
<span id="728"> 728</span>
<span id="729"> 729</span>
<span id="730"> 730</span>
<span id="731"> 731</span>
<span id="732"> 732</span>
<span id="733"> 733</span>
<span id="734"> 734</span>
<span id="735"> 735</span>
<span id="736"> 736</span>
<span id="737"> 737</span>
<span id="738"> 738</span>
<span id="739"> 739</span>
<span id="740"> 740</span>
<span id="741"> 741</span>
<span id="742"> 742</span>
<span id="743"> 743</span>
<span id="744"> 744</span>
<span id="745"> 745</span>
<span id="746"> 746</span>
<span id="747"> 747</span>
<span id="748"> 748</span>
<span id="749"> 749</span>
<span id="750"> 750</span>
<span id="751"> 751</span>
<span id="752"> 752</span>
<span id="753"> 753</span>
<span id="754"> 754</span>
<span id="755"> 755</span>
<span id="756"> 756</span>
<span id="757"> 757</span>
<span id="758"> 758</span>
<span id="759"> 759</span>
<span id="760"> 760</span>
<span id="761"> 761</span>
<span id="762"> 762</span>
<span id="763"> 763</span>
<span id="764"> 764</span>
<span id="765"> 765</span>
<span id="766"> 766</span>
<span id="767"> 767</span>
<span id="768"> 768</span>
<span id="769"> 769</span>
<span id="770"> 770</span>
<span id="771"> 771</span>
<span id="772"> 772</span>
<span id="773"> 773</span>
<span id="774"> 774</span>
<span id="775"> 775</span>
<span id="776"> 776</span>
<span id="777"> 777</span>
<span id="778"> 778</span>
<span id="779"> 779</span>
<span id="780"> 780</span>
<span id="781"> 781</span>
<span id="782"> 782</span>
<span id="783"> 783</span>
<span id="784"> 784</span>
<span id="785"> 785</span>
<span id="786"> 786</span>
<span id="787"> 787</span>
<span id="788"> 788</span>
<span id="789"> 789</span>
<span id="790"> 790</span>
<span id="791"> 791</span>
<span id="792"> 792</span>
<span id="793"> 793</span>
<span id="794"> 794</span>
<span id="795"> 795</span>
<span id="796"> 796</span>
<span id="797"> 797</span>
<span id="798"> 798</span>
<span id="799"> 799</span>
<span id="800"> 800</span>
<span id="801"> 801</span>
<span id="802"> 802</span>
<span id="803"> 803</span>
<span id="804"> 804</span>
<span id="805"> 805</span>
<span id="806"> 806</span>
<span id="807"> 807</span>
<span id="808"> 808</span>
<span id="809"> 809</span>
<span id="810"> 810</span>
<span id="811"> 811</span>
<span id="812"> 812</span>
<span id="813"> 813</span>
<span id="814"> 814</span>
<span id="815"> 815</span>
<span id="816"> 816</span>
<span id="817"> 817</span>
<span id="818"> 818</span>
<span id="819"> 819</span>
<span id="820"> 820</span>
<span id="821"> 821</span>
<span id="822"> 822</span>
<span id="823"> 823</span>
<span id="824"> 824</span>
<span id="825"> 825</span>
<span id="826"> 826</span>
<span id="827"> 827</span>
<span id="828"> 828</span>
<span id="829"> 829</span>
<span id="830"> 830</span>
<span id="831"> 831</span>
<span id="832"> 832</span>
<span id="833"> 833</span>
<span id="834"> 834</span>
<span id="835"> 835</span>
<span id="836"> 836</span>
<span id="837"> 837</span>
<span id="838"> 838</span>
<span id="839"> 839</span>
<span id="840"> 840</span>
<span id="841"> 841</span>
<span id="842"> 842</span>
<span id="843"> 843</span>
<span id="844"> 844</span>
<span id="845"> 845</span>
<span id="846"> 846</span>
<span id="847"> 847</span>
<span id="848"> 848</span>
<span id="849"> 849</span>
<span id="850"> 850</span>
<span id="851"> 851</span>
<span id="852"> 852</span>
<span id="853"> 853</span>
<span id="854"> 854</span>
<span id="855"> 855</span>
<span id="856"> 856</span>
<span id="857"> 857</span>
<span id="858"> 858</span>
<span id="859"> 859</span>
<span id="860"> 860</span>
<span id="861"> 861</span>
<span id="862"> 862</span>
<span id="863"> 863</span>
<span id="864"> 864</span>
<span id="865"> 865</span>
<span id="866"> 866</span>
<span id="867"> 867</span>
<span id="868"> 868</span>
<span id="869"> 869</span>
<span id="870"> 870</span>
<span id="871"> 871</span>
<span id="872"> 872</span>
<span id="873"> 873</span>
<span id="874"> 874</span>
<span id="875"> 875</span>
<span id="876"> 876</span>
<span id="877"> 877</span>
<span id="878"> 878</span>
<span id="879"> 879</span>
<span id="880"> 880</span>
<span id="881"> 881</span>
<span id="882"> 882</span>
<span id="883"> 883</span>
<span id="884"> 884</span>
<span id="885"> 885</span>
<span id="886"> 886</span>
<span id="887"> 887</span>
<span id="888"> 888</span>
<span id="889"> 889</span>
<span id="890"> 890</span>
<span id="891"> 891</span>
<span id="892"> 892</span>
<span id="893"> 893</span>
<span id="894"> 894</span>
<span id="895"> 895</span>
<span id="896"> 896</span>
<span id="897"> 897</span>
<span id="898"> 898</span>
<span id="899"> 899</span>
<span id="900"> 900</span>
<span id="901"> 901</span>
<span id="902"> 902</span>
<span id="903"> 903</span>
<span id="904"> 904</span>
<span id="905"> 905</span>
<span id="906"> 906</span>
<span id="907"> 907</span>
<span id="908"> 908</span>
<span id="909"> 909</span>
<span id="910"> 910</span>
<span id="911"> 911</span>
<span id="912"> 912</span>
<span id="913"> 913</span>
<span id="914"> 914</span>
<span id="915"> 915</span>
<span id="916"> 916</span>
<span id="917"> 917</span>
<span id="918"> 918</span>
<span id="919"> 919</span>
<span id="920"> 920</span>
<span id="921"> 921</span>
<span id="922"> 922</span>
<span id="923"> 923</span>
<span id="924"> 924</span>
<span id="925"> 925</span>
<span id="926"> 926</span>
<span id="927"> 927</span>
<span id="928"> 928</span>
<span id="929"> 929</span>
<span id="930"> 930</span>
<span id="931"> 931</span>
<span id="932"> 932</span>
<span id="933"> 933</span>
<span id="934"> 934</span>
<span id="935"> 935</span>
<span id="936"> 936</span>
<span id="937"> 937</span>
<span id="938"> 938</span>
<span id="939"> 939</span>
<span id="940"> 940</span>
<span id="941"> 941</span>
<span id="942"> 942</span>
<span id="943"> 943</span>
<span id="944"> 944</span>
<span id="945"> 945</span>
<span id="946"> 946</span>
<span id="947"> 947</span>
<span id="948"> 948</span>
<span id="949"> 949</span>
<span id="950"> 950</span>
<span id="951"> 951</span>
<span id="952"> 952</span>
<span id="953"> 953</span>
<span id="954"> 954</span>
<span id="955"> 955</span>
<span id="956"> 956</span>
<span id="957"> 957</span>
<span id="958"> 958</span>
<span id="959"> 959</span>
<span id="960"> 960</span>
<span id="961"> 961</span>
<span id="962"> 962</span>
<span id="963"> 963</span>
<span id="964"> 964</span>
<span id="965"> 965</span>
<span id="966"> 966</span>
<span id="967"> 967</span>
<span id="968"> 968</span>
<span id="969"> 969</span>
<span id="970"> 970</span>
<span id="971"> 971</span>
<span id="972"> 972</span>
<span id="973"> 973</span>
<span id="974"> 974</span>
<span id="975"> 975</span>
<span id="976"> 976</span>
<span id="977"> 977</span>
<span id="978"> 978</span>
<span id="979"> 979</span>
<span id="980"> 980</span>
<span id="981"> 981</span>
<span id="982"> 982</span>
<span id="983"> 983</span>
<span id="984"> 984</span>
<span id="985"> 985</span>
<span id="986"> 986</span>
<span id="987"> 987</span>
<span id="988"> 988</span>
<span id="989"> 989</span>
<span id="990"> 990</span>
<span id="991"> 991</span>
<span id="992"> 992</span>
<span id="993"> 993</span>
<span id="994"> 994</span>
<span id="995"> 995</span>
<span id="996"> 996</span>
<span id="997"> 997</span>
<span id="998"> 998</span>
<span id="999"> 999</span>
<span id="1000">1000</span>
<span id="1001">1001</span>
<span id="1002">1002</span>
<span id="1003">1003</span>
<span id="1004">1004</span>
<span id="1005">1005</span>
<span id="1006">1006</span>
<span id="1007">1007</span>
<span id="1008">1008</span>
<span id="1009">1009</span>
<span id="1010">1010</span>
<span id="1011">1011</span>
<span id="1012">1012</span>
<span id="1013">1013</span>
<span id="1014">1014</span>
<span id="1015">1015</span>
<span id="1016">1016</span>
<span id="1017">1017</span>
<span id="1018">1018</span>
<span id="1019">1019</span>
<span id="1020">1020</span>
<span id="1021">1021</span>
<span id="1022">1022</span>
<span id="1023">1023</span>
<span id="1024">1024</span>
<span id="1025">1025</span>
<span id="1026">1026</span>
<span id="1027">1027</span>
<span id="1028">1028</span>
<span id="1029">1029</span>
<span id="1030">1030</span>
<span id="1031">1031</span>
<span id="1032">1032</span>
<span id="1033">1033</span>
<span id="1034">1034</span>
<span id="1035">1035</span>
<span id="1036">1036</span>
<span id="1037">1037</span>
<span id="1038">1038</span>
<span id="1039">1039</span>
<span id="1040">1040</span>
<span id="1041">1041</span>
<span id="1042">1042</span>
<span id="1043">1043</span>
<span id="1044">1044</span>
<span id="1045">1045</span>
<span id="1046">1046</span>
<span id="1047">1047</span>
<span id="1048">1048</span>
<span id="1049">1049</span>
<span id="1050">1050</span>
<span id="1051">1051</span>
<span id="1052">1052</span>
<span id="1053">1053</span>
<span id="1054">1054</span>
<span id="1055">1055</span>
<span id="1056">1056</span>
<span id="1057">1057</span>
<span id="1058">1058</span>
<span id="1059">1059</span>
<span id="1060">1060</span>
<span id="1061">1061</span>
<span id="1062">1062</span>
<span id="1063">1063</span>
<span id="1064">1064</span>
<span id="1065">1065</span>
<span id="1066">1066</span>
<span id="1067">1067</span>
<span id="1068">1068</span>
<span id="1069">1069</span>
<span id="1070">1070</span>
<span id="1071">1071</span>
<span id="1072">1072</span>
<span id="1073">1073</span>
<span id="1074">1074</span>
<span id="1075">1075</span>
<span id="1076">1076</span>
<span id="1077">1077</span>
<span id="1078">1078</span>
<span id="1079">1079</span>
<span id="1080">1080</span>
<span id="1081">1081</span>
<span id="1082">1082</span>
<span id="1083">1083</span>
<span id="1084">1084</span>
<span id="1085">1085</span>
<span id="1086">1086</span>
<span id="1087">1087</span>
<span id="1088">1088</span>
<span id="1089">1089</span>
<span id="1090">1090</span>
<span id="1091">1091</span>
<span id="1092">1092</span>
<span id="1093">1093</span>
<span id="1094">1094</span>
<span id="1095">1095</span>
<span id="1096">1096</span>
<span id="1097">1097</span>
<span id="1098">1098</span>
<span id="1099">1099</span>
<span id="1100">1100</span>
<span id="1101">1101</span>
<span id="1102">1102</span>
<span id="1103">1103</span>
<span id="1104">1104</span>
<span id="1105">1105</span>
<span id="1106">1106</span>
<span id="1107">1107</span>
<span id="1108">1108</span>
<span id="1109">1109</span>
<span id="1110">1110</span>
<span id="1111">1111</span>
<span id="1112">1112</span>
<span id="1113">1113</span>
<span id="1114">1114</span>
<span id="1115">1115</span>
<span id="1116">1116</span>
<span id="1117">1117</span>
<span id="1118">1118</span>
<span id="1119">1119</span>
<span id="1120">1120</span>
<span id="1121">1121</span>
<span id="1122">1122</span>
<span id="1123">1123</span>
<span id="1124">1124</span>
<span id="1125">1125</span>
<span id="1126">1126</span>
<span id="1127">1127</span>
<span id="1128">1128</span>
<span id="1129">1129</span>
<span id="1130">1130</span>
<span id="1131">1131</span>
<span id="1132">1132</span>
<span id="1133">1133</span>
<span id="1134">1134</span>
<span id="1135">1135</span>
<span id="1136">1136</span>
<span id="1137">1137</span>
<span id="1138">1138</span>
<span id="1139">1139</span>
<span id="1140">1140</span>
<span id="1141">1141</span>
<span id="1142">1142</span>
<span id="1143">1143</span>
<span id="1144">1144</span>
<span id="1145">1145</span>
<span id="1146">1146</span>
<span id="1147">1147</span>
<span id="1148">1148</span>
<span id="1149">1149</span>
<span id="1150">1150</span>
<span id="1151">1151</span>
<span id="1152">1152</span>
<span id="1153">1153</span>
<span id="1154">1154</span>
<span id="1155">1155</span>
<span id="1156">1156</span>
<span id="1157">1157</span>
</pre><pre class="rust"><code><span class="doccomment">//! Signal support for Unix-like systems.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Signals in Unix are much more functional and versatile than ANSI C signals — there is simply much, much more of them. In addition to that, there is a special group of signals called &quot;real-time signals&quot; (more on those below).</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! # Main signals</span>
<span class="doccomment">//! The [`SignalType`] enumeration provides all standard signals as defined in POSIX.1-2001. More signal types may be added later, which is why exhaustively matching on it is not possible. It can be cheaply converted to a 32-bit integer, though. See its documentation for more on conversions.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! The `set_handler` function is used to create an association between a `SignalType` and a signal handling strategy.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! # Real-time signals</span>
<span class="doccomment">//! In addition to usual signals, there&#39;s a special group of signals called &quot;real-time signals&quot;. Those signals do not have fixed identifiers and are not generated by the system or kernel. Instead, they can only be sent between processes.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! # Signal-safe C functions</span>
<span class="doccomment">//! Very few C functions can be called from a signal handler. Allocating memory, using the thread API and manipulating interval timers, for example, is prohibited in a signal handler. Calling a function which is not signal safe results in undefined behavior, i.e. memory unsafety. Rather than excluding certain specific functions, the POSIX specification only speicifies functions which *are* signal-safe. The following C functions are guaranteed to be safe to call from a signal handler:</span>
<span class="doccomment">//! - `_Exit`</span>
<span class="doccomment">//! - `_exit`</span>
<span class="doccomment">//! - `abort`</span>
<span class="doccomment">//! - `accept`</span>
<span class="doccomment">//! - `access`</span>
<span class="doccomment">//! - `aio_error`</span>
<span class="doccomment">//! - `aio_return`</span>
<span class="doccomment">//! - `aio_suspend`</span>
<span class="doccomment">//! - `alarm`</span>
<span class="doccomment">//! - `bind`</span>
<span class="doccomment">//! - `cfgetispeed`</span>
<span class="doccomment">//! - `cfgetospeed`</span>
<span class="doccomment">//! - `cfsetispeed`</span>
<span class="doccomment">//! - `cfsetospeed`</span>
<span class="doccomment">//! - `chdir`</span>
<span class="doccomment">//! - `chmod`</span>
<span class="doccomment">//! - `chown`</span>
<span class="doccomment">//! - `clock_gettime`</span>
<span class="doccomment">//! - `close`</span>
<span class="doccomment">//! - `connect`</span>
<span class="doccomment">//! - `creat`</span>
<span class="doccomment">//! - `dup`</span>
<span class="doccomment">//! - `dup2`</span>
<span class="doccomment">//! - `execle`</span>
<span class="doccomment">//! - `execve`</span>
<span class="doccomment">//! - `fchmod`</span>
<span class="doccomment">//! - `fchown`</span>
<span class="doccomment">//! - `fcntl`</span>
<span class="doccomment">//! - `fdatasync`</span>
<span class="doccomment">//! - `fork`</span>
<span class="doccomment">//! - `fpathconf`</span>
<span class="doccomment">//! - `fstat`</span>
<span class="doccomment">//! - `fsync`</span>
<span class="doccomment">//! - `ftruncate`</span>
<span class="doccomment">//! - `getegid`</span>
<span class="doccomment">//! - `geteuid`</span>
<span class="doccomment">//! - `getgid`</span>
<span class="doccomment">//! - `getgroups`</span>
<span class="doccomment">//! - `getpeername`</span>
<span class="doccomment">//! - `getpgrp`</span>
<span class="doccomment">//! - `getpid`</span>
<span class="doccomment">//! - `getppid`</span>
<span class="doccomment">//! - `getsockname`</span>
<span class="doccomment">//! - `getsockopt`</span>
<span class="doccomment">//! - `getuid`</span>
<span class="doccomment">//! - `kill`</span>
<span class="doccomment">//! - `link`</span>
<span class="doccomment">//! - `listen`</span>
<span class="doccomment">//! - `lseek`</span>
<span class="doccomment">//! - `lstat`</span>
<span class="doccomment">//! - `mkdir`</span>
<span class="doccomment">//! - `mkfifo`</span>
<span class="doccomment">//! - `open`</span>
<span class="doccomment">//! - `pathconf`</span>
<span class="doccomment">//! - `pause`</span>
<span class="doccomment">//! - `pipe`</span>
<span class="doccomment">//! - `poll`</span>
<span class="doccomment">//! - `posix_trace_event`</span>
<span class="doccomment">//! - `pselect`</span>
<span class="doccomment">//! - `raise`</span>
<span class="doccomment">//! - `read`</span>
<span class="doccomment">//! - `readlink`</span>
<span class="doccomment">//! - `recv`</span>
<span class="doccomment">//! - `recvfrom`</span>
<span class="doccomment">//! - `recvmsg`</span>
<span class="doccomment">//! - `rename`</span>
<span class="doccomment">//! - `rmdir`</span>
<span class="doccomment">//! - `select`</span>
<span class="doccomment">//! - `sem_post`</span>
<span class="doccomment">//! - `send`</span>
<span class="doccomment">//! - `sendmsg`</span>
<span class="doccomment">//! - `sendto`</span>
<span class="doccomment">//! - `setgid`</span>
<span class="doccomment">//! - `setpgid`</span>
<span class="doccomment">//! - `setsid`</span>
<span class="doccomment">//! - `setsockopt`</span>
<span class="doccomment">//! - `setuid`</span>
<span class="doccomment">//! - `shutdown`</span>
<span class="doccomment">//! - `sigaction`</span>
<span class="doccomment">//! - `sigaddset`</span>
<span class="doccomment">//! - `sigdelset`</span>
<span class="doccomment">//! - `sigemptyset`</span>
<span class="doccomment">//! - `sigfillset`</span>
<span class="doccomment">//! - `sigismember`</span>
<span class="doccomment">//! - `signal`</span>
<span class="doccomment">//! - `sigpause`</span>
<span class="doccomment">//! - `sigpending`</span>
<span class="doccomment">//! - `sigprocmask`</span>
<span class="doccomment">//! - `sigqueue`</span>
<span class="doccomment">//! - `sigset`</span>
<span class="doccomment">//! - `sigsuspend`</span>
<span class="doccomment">//! - `sleep`</span>
<span class="doccomment">//! - `sockatmark`</span>
<span class="doccomment">//! - `socket`</span>
<span class="doccomment">//! - `socketpair`</span>
<span class="doccomment">//! - `stat`</span>
<span class="doccomment">//! - `symlink`</span>
<span class="doccomment">//! - `sysconf`</span>
<span class="doccomment">//! - `tcdrain`</span>
<span class="doccomment">//! - `tcflow`</span>
<span class="doccomment">//! - `tcflush`</span>
<span class="doccomment">//! - `tcgetattr`</span>
<span class="doccomment">//! - `tcgetpgrp`</span>
<span class="doccomment">//! - `tcsendbreak`</span>
<span class="doccomment">//! - `tcsetattr`</span>
<span class="doccomment">//! - `tcsetpgrp`</span>
<span class="doccomment">//! - `time`</span>
<span class="doccomment">//! - `timer_getoverrun`</span>
<span class="doccomment">//! - `timer_gettime`</span>
<span class="doccomment">//! - `timer_settime`</span>
<span class="doccomment">//! - `times`</span>
<span class="doccomment">//! - `umask`</span>
<span class="doccomment">//! - `uname`</span>
<span class="doccomment">//! - `unlink`</span>
<span class="doccomment">//! - `utime`</span>
<span class="doccomment">//! - `wait`</span>
<span class="doccomment">//! - `waitpid`</span>
<span class="doccomment">//! - `write`</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Many Rust crates, including the standard library, use signal-unsafe functions not on this list in safe code. For example, `Vec`, `Box` and `Rc`/`Arc` perform memory allocations, and `Mutex`/`RwLock` perform `pthread` calls. For this reason, creating a signal hook is an unsafe operation.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! [`SignalType`]: enum.SignalType.html &quot; &quot;</span>

<span class="attribute">#![<span class="ident">cfg_attr</span>(<span class="ident">not</span>(<span class="ident">unix</span>), <span class="ident">allow</span>(<span class="ident">unused_imports</span>))]</span>

<span class="kw">use</span> <span class="ident">cfg_if::cfg_if</span>;
<span class="kw">use</span> <span class="ident">std</span>::{
    <span class="ident">convert</span>::{<span class="ident">TryFrom</span>, <span class="ident">TryInto</span>},
    <span class="ident">error::Error</span>,
    <span class="ident">fmt</span>::{<span class="self">self</span>, <span class="ident">Display</span>, <span class="ident">Formatter</span>},
    <span class="ident">io</span>,
    <span class="ident">mem::zeroed</span>,
    <span class="ident">panic</span>, <span class="ident">process</span>,
};

<span class="kw">use</span> <span class="ident"><span class="kw">super</span>::imports</span>::<span class="kw-2">*</span>;

<span class="macro">cfg_if!</span> {
    <span class="kw">if</span> <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(
        <span class="ident">target_os</span> <span class="op">=</span> <span class="string">&quot;linux&quot;</span>,
        <span class="ident">target_os</span> <span class="op">=</span> <span class="string">&quot;android&quot;</span>,
    ))]</span> {
        <span class="comment">// don&#39;t care about LinuxThreads lmao</span>
        <span class="kw">const</span> <span class="ident">SIGRTMIN</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="number">34</span>;
        <span class="kw">const</span> <span class="ident">SIGRTMAX</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="number">64</span>;
    } <span class="kw">else</span> <span class="kw">if</span> <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_os</span> <span class="op">=</span> <span class="string">&quot;freebsd&quot;</span>)]</span> {
        <span class="kw">const</span> <span class="ident">SIGRTMIN</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="number">65</span>;
        <span class="kw">const</span> <span class="ident">SIGRTMAX</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="number">126</span>;
    } <span class="kw">else</span> <span class="kw">if</span> <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_os</span> <span class="op">=</span> <span class="string">&quot;netbsd&quot;</span>)]</span> {
        <span class="kw">const</span> <span class="ident">SIGRTMIN</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="number">33</span>;
        <span class="kw">const</span> <span class="ident">SIGRTMAX</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="number">63</span>;
    } <span class="kw">else</span> <span class="kw">if</span> <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_os</span> <span class="op">=</span> <span class="string">&quot;redox&quot;</span>)]</span> {
        <span class="kw">const</span> <span class="ident">SIGRTMIN</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="number">27</span>;
        <span class="kw">const</span> <span class="ident">SIGRTMAX</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="number">31</span>;
    } <span class="kw">else</span> {
        <span class="kw">const</span> <span class="ident">SIGRTMIN</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="number">1</span>; <span class="comment">// min is smaller than max so that the sloppy calculation works</span>
        <span class="kw">const</span> <span class="ident">SIGRTMAX</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="number">0</span>;
    }
}

<span class="doccomment">/// Whether real-time signals are supported at all.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The platforms for which `interprocess` has explicit support for real-time signals are:</span>
<span class="doccomment">/// - Linux</span>
<span class="doccomment">///     - includes Android</span>
<span class="doccomment">/// - FreeBSD</span>
<span class="doccomment">/// - NetBSD</span>
<span class="doccomment">/// - Redox</span>
<span class="kw">pub</span> <span class="kw">const</span> <span class="ident">REALTIME_SIGNALS_SUPPORTED</span>: <span class="ident">bool</span> <span class="op">=</span> <span class="ident">NUM_REALTIME_SIGNALS</span> <span class="op">!</span><span class="op">=</span> <span class="number">0</span>;
<span class="doccomment">/// How many real-time signals are supported. Remember that real-time signals start from 0, so this number is higher than the highest possible real-time signal by 1.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Platform-specific values for this constant are:</span>
<span class="doccomment">/// - **Linux** and **NetBSD**: 31</span>
<span class="doccomment">/// - **FreeBSD**: 62</span>
<span class="doccomment">/// - **Redox**: 5 (does not conform with POSIX)</span>
<span class="kw">pub</span> <span class="kw">const</span> <span class="ident">NUM_REALTIME_SIGNALS</span>: <span class="ident">u32</span> <span class="op">=</span> (<span class="ident">SIGRTMAX</span> <span class="op">-</span> <span class="ident">SIGRTMIN</span> <span class="op">+</span> <span class="number">1</span>) <span class="kw">as</span> <span class="ident">u32</span>;
<span class="doccomment">/// Returns `true` if the specified signal is a valid real-time signal value, `false` otherwise.</span>
<span class="attribute">#[<span class="ident">inline</span>]</span>
<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">clippy::absurd_extreme_comparisons</span>)]</span> <span class="comment">// For systems where there are no realtime signals</span>
<span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">is_valid_rtsignal</span>(<span class="ident">rtsignal</span>: <span class="ident">u32</span>) -&gt; <span class="ident">bool</span> {
    <span class="ident">rtsignal</span> <span class="op">&lt;</span> <span class="ident">NUM_REALTIME_SIGNALS</span>
}

<span class="doccomment">/// The first field is the current method of handling a specific signal, the second one is the flags which were set for it.</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">all</span>(<span class="ident">unix</span>, <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;signals&quot;</span>))]</span>
<span class="kw">type</span> <span class="ident">HandlerAndFlags</span> <span class="op">=</span> (<span class="ident">SignalHandler</span>, <span class="ident">i32</span>);

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">all</span>(<span class="ident">unix</span>, <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;signals&quot;</span>))]</span>
<span class="kw">static</span> <span class="ident">HANDLERS</span>: <span class="ident">Lazy</span><span class="op">&lt;</span><span class="ident">RwLock</span><span class="op">&lt;</span><span class="ident">IntMap</span><span class="op">&lt;</span><span class="ident">HandlerAndFlags</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Lazy::new</span>(<span class="op">|</span><span class="op">|</span> <span class="ident">RwLock::new</span>(<span class="ident">IntMap::new</span>()));

<span class="doccomment">/// Installs the specified handler for the specified standard signal, using the default values for the flags.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// See [`HandlerOptions`] builder if you&#39;d like to customize the flags.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Example</span>
<span class="doccomment">/// ```no_run</span>
<span class="doccomment">/// # fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span>
<span class="doccomment">/// # #[cfg(all(unix, feature = &quot;signals&quot;))] {</span>
<span class="doccomment">/// use interprocess::os::unix::signal::{self, SignalType, SignalHandler};</span>
<span class="doccomment">///</span>
<span class="doccomment">/// let handler = unsafe {</span>
<span class="doccomment">///     // Since signal handlers are restricted to a specific set of C functions, creating a</span>
<span class="doccomment">///     // handler from an arbitrary function is unsafe because it might call a function</span>
<span class="doccomment">///     // outside the list, and there&#39;s no real way to know that at compile time with the</span>
<span class="doccomment">///     // current version of Rust. Since we&#39;re only using the write() system call here, this</span>
<span class="doccomment">///     // is safe.</span>
<span class="doccomment">///     SignalHandler::from_fn(|| {</span>
<span class="doccomment">///         println!(&quot;You pressed Ctrl-C!&quot;);</span>
<span class="doccomment">///     })</span>
<span class="doccomment">/// };</span>
<span class="doccomment">///</span>
<span class="doccomment">/// // Install our handler for the KeyboardInterrupt signal type.</span>
<span class="doccomment">/// signal::set_handler(SignalType::KeyboardInterrupt, handler)?;</span>
<span class="doccomment">/// # }</span>
<span class="doccomment">/// # Ok(()) }</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// [`HandlerOptions`]: struct.HandlerOptions.html &quot; &quot;</span>
<span class="attribute">#[<span class="ident">inline</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_handler</span>(<span class="ident">signal_type</span>: <span class="ident">SignalType</span>, <span class="ident">handler</span>: <span class="ident">SignalHandler</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">SetHandlerError</span><span class="op">&gt;</span> {
    <span class="ident">HandlerOptions::for_signal</span>(<span class="ident">signal_type</span>)
        .<span class="ident">set_new_handler</span>(<span class="ident">handler</span>)
        .<span class="ident">set</span>()
}
<span class="doccomment">/// Installs the specified handler for the specified unsafe signal, using the default values for the flags.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// See [`HandlerOptions`] builder if you&#39;d like to customize the flags.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Safety</span>
<span class="doccomment">/// See the [`set_unsafe`] safety notes.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Example</span>
<span class="doccomment">/// ```no_run</span>
<span class="doccomment">/// # fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span>
<span class="doccomment">/// # #[cfg(all(unix, feature = &quot;signals&quot;))] {</span>
<span class="doccomment">/// use interprocess::os::unix::signal::{self, SignalType, SignalHandler};</span>
<span class="doccomment">///</span>
<span class="doccomment">/// let handler = unsafe {</span>
<span class="doccomment">///     // Since signal handlers are restricted to a specific set of C functions, creating a</span>
<span class="doccomment">///     // handler from an arbitrary function is unsafe because it might call a function</span>
<span class="doccomment">///     // outside the list, and there&#39;s no real way to know that at compile time with the</span>
<span class="doccomment">///     // current version of Rust. Since we&#39;re only using the write() system call here, this</span>
<span class="doccomment">///     // is safe.</span>
<span class="doccomment">///     SignalHandler::from_fn(|| {</span>
<span class="doccomment">///         println!(&quot;Oh no, the motherboard broke!&quot;);</span>
<span class="doccomment">///         std::process::abort();</span>
<span class="doccomment">///     })</span>
<span class="doccomment">/// };</span>
<span class="doccomment">///</span>
<span class="doccomment">/// unsafe {</span>
<span class="doccomment">///     // Install our handler for the MemoryBusError signal type.</span>
<span class="doccomment">///     signal::set_unsafe_handler(SignalType::MemoryBusError, handler)?;</span>
<span class="doccomment">/// }</span>
<span class="doccomment">/// # }</span>
<span class="doccomment">/// # Ok(()) }</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// [`HandlerOptions`]: struct.HandlerOptions.html &quot; &quot;</span>
<span class="doccomment">/// [`set_unsafe`]: struct.HandlerOptions.html#method.set_unsafe &quot; &quot;</span>
<span class="attribute">#[<span class="ident">inline</span>]</span>
<span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">set_unsafe_handler</span>(
    <span class="ident">signal_type</span>: <span class="ident">SignalType</span>,
    <span class="ident">handler</span>: <span class="ident">SignalHandler</span>,
) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">SetHandlerError</span><span class="op">&gt;</span> {
    <span class="ident">HandlerOptions::for_signal</span>(<span class="ident">signal_type</span>)
        .<span class="ident">set_new_handler</span>(<span class="ident">handler</span>)
        .<span class="ident">set_unsafe</span>()
}
<span class="doccomment">/// Installs the specified handler for the specified real-time signal, using the default values for the flags.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// See [`HandlerOptions`] builder if you&#39;d like to customize the flags.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Example</span>
<span class="doccomment">/// ```no_run</span>
<span class="doccomment">/// # fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span>
<span class="doccomment">/// # #[cfg(all(unix, feature = &quot;signals&quot;))] {</span>
<span class="doccomment">/// use interprocess::os::unix::signal::{self, SignalHandler};</span>
<span class="doccomment">///</span>
<span class="doccomment">/// let handler = unsafe {</span>
<span class="doccomment">///     // Since signal handlers are restricted to a specific set of C functions, creating a</span>
<span class="doccomment">///     // handler from an arbitrary function is unsafe because it might call a function</span>
<span class="doccomment">///     // outside the list, and there&#39;s no real way to know that at compile time with the</span>
<span class="doccomment">///     // current version of Rust. Since we&#39;re only using the write() system call here, this</span>
<span class="doccomment">///     // is safe.</span>
<span class="doccomment">///     SignalHandler::from_fn(|| {</span>
<span class="doccomment">///         println!(&quot;You sent a real-time signal!&quot;);</span>
<span class="doccomment">///     })</span>
<span class="doccomment">/// };</span>
<span class="doccomment">///</span>
<span class="doccomment">/// // Install our handler for the real-time signal 0.</span>
<span class="doccomment">/// signal::set_rthandler(0, handler)?;</span>
<span class="doccomment">/// # }</span>
<span class="doccomment">/// # Ok(()) }</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// [`HandlerOptions`]: struct.HandlerOptions.html &quot; &quot;</span>
<span class="attribute">#[<span class="ident">inline</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_rthandler</span>(<span class="ident">rtsignal</span>: <span class="ident">u32</span>, <span class="ident">handler</span>: <span class="ident">SignalHandler</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">SetHandlerError</span><span class="op">&gt;</span> {
    <span class="ident">HandlerOptions::for_rtsignal</span>(<span class="ident">rtsignal</span>)
        .<span class="ident">set_new_handler</span>(<span class="ident">handler</span>)
        .<span class="ident">set</span>()
}

<span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">install_hook</span>(<span class="ident">signum</span>: <span class="ident">i32</span>, <span class="ident">hook</span>: <span class="ident">usize</span>, <span class="ident">flags</span>: <span class="ident">i32</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">success</span> <span class="op">=</span> {
        <span class="kw">let</span> [<span class="kw-2">mut</span> <span class="ident">old_handler</span>, <span class="kw-2">mut</span> <span class="ident">new_handler</span>] <span class="op">=</span> [<span class="ident">zeroed</span>::<span class="op">&lt;</span><span class="ident">sigaction</span><span class="op">&gt;</span>(); <span class="number">2</span>];
        <span class="ident">new_handler</span>.<span class="ident">sa_sigaction</span> <span class="op">=</span> <span class="ident">hook</span> <span class="kw">as</span> <span class="ident">usize</span>;
        <span class="ident">new_handler</span>.<span class="ident">sa_flags</span> <span class="op">=</span> <span class="ident">flags</span>;
        <span class="ident">libc::sigaction</span>(<span class="ident">signum</span>, <span class="kw-2">&amp;</span><span class="ident">new_handler</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="kw">_</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">old_handler</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="kw">_</span>) <span class="op">!</span><span class="op">=</span> <span class="op">-</span><span class="number">1</span>
    };
    <span class="kw">if</span> <span class="ident">success</span> {
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">io::Error::last_os_error</span>())
    }
}

<span class="doccomment">/// Options for installing a signal handler.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Example</span>
<span class="doccomment">/// ```no_run</span>
<span class="doccomment">/// # fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span>
<span class="doccomment">/// # #[cfg(all(unix, feature = &quot;signals&quot;))] {</span>
<span class="doccomment">/// use interprocess::os::unix::signal::{self, SignalType, SignalHandler};</span>
<span class="doccomment">///</span>
<span class="doccomment">/// let handler = unsafe {</span>
<span class="doccomment">///     // Since signal handlers are restricted to a specific set of C functions, creating a</span>
<span class="doccomment">///     // handler from an arbitrary function is unsafe because it might call a function</span>
<span class="doccomment">///     // outside the list, and there&#39;s no real way to know that at compile time with the</span>
<span class="doccomment">///     // current version of Rust. Since we&#39;re only using the write() system call here, this</span>
<span class="doccomment">///     // is safe.</span>
<span class="doccomment">///     SignalHandler::from_fn(|| {</span>
<span class="doccomment">///         println!(&quot;You pressed Ctrl-C!&quot;);</span>
<span class="doccomment">///     })</span>
<span class="doccomment">/// };</span>
<span class="doccomment">///</span>
<span class="doccomment">/// // Let&#39;s use the builder to customize the signal handler:</span>
<span class="doccomment">/// signal::HandlerOptions::for_signal(SignalType::KeyboardInterrupt)</span>
<span class="doccomment">///     .set_new_handler(handler)</span>
<span class="doccomment">///     .auto_reset_handler(true) // Let&#39;s remove the signal handler after it fires once.</span>
<span class="doccomment">///     .system_call_restart(false) // Avoid restarting system calls and let them fail with the</span>
<span class="doccomment">///                                 // Interrupted error type. There normally isn&#39;t a reason to</span>
<span class="doccomment">///                                 // do this, but for the sake of the example, let&#39;s assume</span>
<span class="doccomment">///                                 // that there is.</span>
<span class="doccomment">///     .set()?; // Finalize the builder by installing the handler.</span>
<span class="doccomment">/// # }</span>
<span class="doccomment">/// # Ok(()) }</span>
<span class="doccomment">/// ```</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">HandlerOptions</span> {
    <span class="ident">signal</span>: <span class="ident">i32</span>,
    <span class="doccomment">/// The handler to be set up. If `None`, the handler is not changed by the call.</span>
    <span class="kw">pub</span> <span class="ident">handler</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">SignalHandler</span><span class="op">&gt;</span>,
    <span class="doccomment">/// For the [`ChildProcessEvent`] signal, this option *disables* receiving the signal if it was generated because the child process was suspended (using any signal which suspends a process, such as [`Suspend`] or [`ForceSuspend`]) or [resumed][`Continue`].</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If enabled on a signal which is not [`ChildProcessEvent`], a panic is produced in debug builds when [`set`] is called; in release builds, the flag is simply ignored.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`ChildProcessEvent`]: enum.SignalType.html#variant.ChildProcessEvent &quot; &quot;</span>
    <span class="doccomment">/// [`Suspend`]: enum.SignalType.html#variant.Suspend &quot; &quot;</span>
    <span class="doccomment">/// [`ForceSuspend`]: enum.SignalType.html#variant.ForceSuspend &quot; &quot;</span>
    <span class="doccomment">/// [`Continue`]: enum.SignalType.html#variant.Continue &quot; &quot;</span>
    <span class="doccomment">/// [`set`]: #method.set &quot; &quot;</span>
    <span class="kw">pub</span> <span class="ident">ignore_child_stop_events</span>: <span class="ident">bool</span>,
    <span class="doccomment">/// Allow the signal handler to interrupt a previous invocation of itself. If disabled, the signal handler will disable its own signal when called and restore previous state when it finishes executing. If not, an infinite amount of signals can be received on top of each other, which is likely a stack overflow risk.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If enabled but the handler is [set to use the default handling method][`Default`] from the OS, a panic is produced in debug builds when [`set`] is called; in release builds, the flag is simply ignored.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`Default`]: enum.SignalHandler.html#variant.Default &quot; &quot;</span>
    <span class="doccomment">/// [`set`]: #method.set &quot; &quot;</span>
    <span class="kw">pub</span> <span class="ident">recursive_handler</span>: <span class="ident">bool</span>,
    <span class="doccomment">/// Automatically restart certain system calls instead of failing with the [`Interrupted`] error type. Some other system calls are not restarted with this function and may fail with [`Interrupted`] anyway. Consult your manual pages for more details.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`Interrupted`]: https://doc.rust-lang.org/std/io/enum.ErrorKind.html#variant.Interrupted &quot; &quot;</span>
    <span class="kw">pub</span> <span class="ident">system_call_restart</span>: <span class="ident">bool</span>,
    <span class="doccomment">/// Automatically reset the handler to the default handling method whenever it is executed.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// If enabled but the handler is [set to use the default handling method][`Default`] from the OS, a panic is produced in debug builds when [`set`] is called; in release builds, the flag is simply ignored.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`Default`]: enum.SignalHandler.html#variant.Default &quot; &quot;</span>
    <span class="doccomment">/// [`set`]: #method.set &quot; &quot;</span>
    <span class="kw">pub</span> <span class="ident">auto_reset_handler</span>: <span class="ident">bool</span>,
}
<span class="kw">impl</span> <span class="ident">HandlerOptions</span> {
    <span class="doccomment">/// Creates a builder for a handler for the specified signal.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">for_signal</span>(<span class="ident">signal</span>: <span class="ident">SignalType</span>) -&gt; <span class="self">Self</span> {
        <span class="self">Self</span> {
            <span class="ident">signal</span>: <span class="ident">signal</span>.<span class="ident">into</span>(),
            <span class="ident">handler</span>: <span class="prelude-val">None</span>,
            <span class="ident">ignore_child_stop_events</span>: <span class="bool-val">false</span>,
            <span class="ident">recursive_handler</span>: <span class="bool-val">false</span>,
            <span class="ident">system_call_restart</span>: <span class="bool-val">true</span>,
            <span class="ident">auto_reset_handler</span>: <span class="bool-val">false</span>,
        }
    }
    <span class="doccomment">/// Creates a builder for a handler for the specified real-time signal.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Panics</span>
    <span class="doccomment">/// Guaranteed to panic if the specified real-time signal is outside the range of real-time signals supported by the OS. See [`NUM_REALTIME_SIGNALS`].</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`NUM_REALTIME_SIGNALS`]: constant.NUM_REALTIME_SIGNALS.html &quot; &quot;</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">for_rtsignal</span>(<span class="ident">rtsignal</span>: <span class="ident">u32</span>) -&gt; <span class="self">Self</span> {
        <span class="macro">assert!</span>(
            <span class="ident">is_valid_rtsignal</span>(<span class="ident">rtsignal</span>),
            <span class="string">&quot;invalid real-time signal value — check the NUM_REALTIME_SIGNALS constant to see how \
            many are supported&quot;</span>
        );
        <span class="self">Self</span> {
            <span class="ident">signal</span>: <span class="ident">rtsignal</span> <span class="kw">as</span> <span class="ident">i32</span>,
            <span class="ident">handler</span>: <span class="prelude-val">None</span>,
            <span class="ident">ignore_child_stop_events</span>: <span class="bool-val">false</span>,
            <span class="ident">recursive_handler</span>: <span class="bool-val">false</span>,
            <span class="ident">system_call_restart</span>: <span class="bool-val">true</span>,
            <span class="ident">auto_reset_handler</span>: <span class="bool-val">false</span>,
        }
    }
    <span class="doccomment">/// Sets the handler for the signal to the specified value. If `None`, the old value is used.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_new_handler</span>(<span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">handler</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">SignalHandler</span><span class="op">&gt;</span><span class="op">&gt;</span>) -&gt; <span class="self">Self</span> {
        <span class="self">self</span>.<span class="ident">handler</span> <span class="op">=</span> <span class="ident">handler</span>.<span class="ident">into</span>();
        <span class="self">self</span>
    }
    <span class="doccomment">/// Sets the [`ignore_child_stop_events`] flag to the specified value.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`ignore_child_stop_events`]: #structfield.ignore_child_stop_events &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">ignore_child_stop_events</span>(<span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">ignore</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span>) -&gt; <span class="self">Self</span> {
        <span class="self">self</span>.<span class="ident">ignore_child_stop_events</span> <span class="op">=</span> <span class="ident">ignore</span>.<span class="ident">into</span>();
        <span class="self">self</span>
    }
    <span class="doccomment">/// Sets the [`recursive_handler`] flag to the specified value.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`recursive_handler`]: #structfield.recursive_handler &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">recursive_handler</span>(<span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">recursive</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span>) -&gt; <span class="self">Self</span> {
        <span class="self">self</span>.<span class="ident">recursive_handler</span> <span class="op">=</span> <span class="ident">recursive</span>.<span class="ident">into</span>();
        <span class="self">self</span>
    }
    <span class="doccomment">/// Sets the [`system_call_restart`] flag to the specified value.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`system_call_restart`]: #structfield.system_call_restart &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">system_call_restart</span>(<span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">restart</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span>) -&gt; <span class="self">Self</span> {
        <span class="self">self</span>.<span class="ident">system_call_restart</span> <span class="op">=</span> <span class="ident">restart</span>.<span class="ident">into</span>();
        <span class="self">self</span>
    }
    <span class="doccomment">/// Sets the [`auto_reset_handler`] flag to the specified value.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`auto_reset_handler`]: #structfield.auto_reset_handler &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">auto_reset_handler</span>(<span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">reset</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span>) -&gt; <span class="self">Self</span> {
        <span class="self">self</span>.<span class="ident">auto_reset_handler</span> <span class="op">=</span> <span class="ident">reset</span>.<span class="ident">into</span>();
        <span class="self">self</span>
    }
    <span class="doccomment">/// Installs the signal handler.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set</span>(<span class="self">self</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">SetHandlerError</span><span class="op">&gt;</span> {
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">val</span>) <span class="op">=</span> <span class="ident">SignalType::try_from</span>(<span class="self">self</span>.<span class="ident">signal</span>) {
            <span class="kw">if</span> <span class="ident">val</span>.<span class="ident">is_unsafe</span>() {
                <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">SetHandlerError::UnsafeSignal</span>);
            }
        }
        <span class="kw">unsafe</span> { <span class="self">self</span>.<span class="ident">set_unsafe</span>() }
    }

    <span class="doccomment">/// Installs the signal handler, even if the signal being handled is unsafe.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Safety</span>
    <span class="doccomment">/// The handler and all code that may or may not execute afterwards must be prepared for the aftermath of what might&#39;ve caused the signal.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`SegmentationFault`] or [`BusError`] are most likely caused by undefined behavior invoked from Rust (the former is caused by dereferencing invalid memory, the latter is caused by dereferencing an incorrectly aligned pointer on ISAs like ARM which do not tolerate misaligned pointers), which means that the program is unsound and the only meaningful thing to do is to capture as much information as possible in a safe way — preferably using OS services to create a dump, rather than trying to read the program&#39;s global state, which might be irreversibly corrupted — and write the crash dump to some on-disk location.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`SegmentationFault`]: enum.SignalType.html#variant.SegmentationFault &quot; &quot;</span>
    <span class="doccomment">/// [`BusError`]: enum.SignalType.html#variant.BusError &quot; &quot;</span>
    <span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">set_unsafe</span>(<span class="self">self</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">SetHandlerError</span><span class="op">&gt;</span> {
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">val</span>) <span class="op">=</span> <span class="ident">SignalType::try_from</span>(<span class="self">self</span>.<span class="ident">signal</span>) {
            <span class="kw">if</span> <span class="ident">val</span>.<span class="ident">is_unblockable</span>() {
                <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">SetHandlerError::UnblockableSignal</span>(<span class="ident">val</span>));
            }
        } <span class="kw">else</span> <span class="kw">if</span> <span class="op">!</span><span class="ident">is_valid_rtsignal</span>(<span class="self">self</span>.<span class="ident">signal</span> <span class="kw">as</span> <span class="ident">u32</span>) {
            <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">SetHandlerError::RealTimeSignalOutOfBounds</span> {
                <span class="ident">attempted</span>: <span class="self">self</span>.<span class="ident">signal</span> <span class="kw">as</span> <span class="ident">u32</span>,
                <span class="ident">max</span>: <span class="ident">NUM_REALTIME_SIGNALS</span>,
            });
        }
        <span class="kw">let</span> <span class="ident">handlers</span> <span class="op">=</span> <span class="ident">HANDLERS</span>.<span class="ident">upgradable_read</span>();
        <span class="kw">let</span> <span class="ident">new_flags</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">flags_as_i32</span>();
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">need_to_upgrade_handle</span> <span class="op">=</span> <span class="bool-val">false</span>;
        <span class="kw">let</span> <span class="ident">need_to_install_hook</span> <span class="op">=</span>
            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">existing_handler</span>, <span class="ident">existing_flags</span>)) <span class="op">=</span> <span class="ident">handlers</span>.<span class="ident">get</span>(<span class="self">self</span>.<span class="ident">signal</span> <span class="kw">as</span> <span class="ident">u64</span>) {
                <span class="comment">// This signal&#39;s handler was set before — check if we need to install new flags or if</span>
                <span class="comment">// one is default and another isn&#39;t, which would mean that either that no hook was</span>
                <span class="comment">// installed and we have to install one or there was one installed but we need to</span>
                <span class="comment">// install the default hook explicitly.</span>
                <span class="kw">let</span> <span class="ident">new_handler</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">handler</span>.<span class="ident">unwrap_or_default</span>();
                <span class="kw">if</span> <span class="ident">new_handler</span> <span class="op">!</span><span class="op">=</span> <span class="kw-2">*</span><span class="ident">existing_handler</span> <span class="op">|</span><span class="op">|</span> <span class="ident">new_flags</span> <span class="op">!</span><span class="op">=</span> <span class="kw-2">*</span><span class="ident">existing_flags</span> {
                    <span class="ident">need_to_upgrade_handle</span> <span class="op">=</span> <span class="bool-val">true</span>;
                    <span class="bool-val">true</span>
                } <span class="kw">else</span> {
                    <span class="kw">let</span> <span class="ident">one_handler_is_default_and_another_isnt</span> <span class="op">=</span> (<span class="ident">new_handler</span>.<span class="ident">is_default</span>()
                        <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="ident">existing_handler</span>.<span class="ident">is_default</span>())
                        <span class="op">|</span><span class="op">|</span> (<span class="op">!</span><span class="ident">new_handler</span>.<span class="ident">is_default</span>() <span class="op">&amp;&amp;</span> <span class="ident">existing_handler</span>.<span class="ident">is_default</span>());
                    <span class="kw-2">*</span><span class="ident">existing_flags</span> <span class="op">!</span><span class="op">=</span> <span class="ident">new_flags</span> <span class="op">|</span><span class="op">|</span> <span class="ident">one_handler_is_default_and_another_isnt</span>
                }
            } <span class="kw">else</span> {
                <span class="ident">need_to_upgrade_handle</span> <span class="op">=</span> <span class="bool-val">true</span>;
                <span class="op">!</span><span class="self">self</span>.<span class="ident">handler</span>.<span class="ident">unwrap_or_default</span>().<span class="ident">is_default</span>()
            };
        <span class="kw">if</span> <span class="ident">need_to_upgrade_handle</span> {
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">handlers</span> <span class="op">=</span> <span class="ident">RwLockUpgradableReadGuard::upgrade</span>(<span class="ident">handlers</span>);
            <span class="kw">let</span> <span class="ident">signal_u64</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">signal</span> <span class="kw">as</span> <span class="ident">u64</span>;
            <span class="ident">handlers</span>.<span class="ident">remove</span>(<span class="ident">signal_u64</span>);
            <span class="ident">handlers</span>.<span class="ident">insert</span>(<span class="ident">signal_u64</span>, (<span class="self">self</span>.<span class="ident">handler</span>.<span class="ident">unwrap_or_default</span>(), <span class="ident">new_flags</span>));
        } <span class="kw">else</span> {
            <span class="ident">drop</span>(<span class="ident">handlers</span>);
        }
        <span class="kw">if</span> <span class="ident">need_to_install_hook</span> {
            <span class="kw">let</span> <span class="ident">hook_val</span> <span class="op">=</span> <span class="kw">match</span> <span class="self">self</span>.<span class="ident">handler</span>.<span class="ident">unwrap_or_default</span>() {
                <span class="ident">SignalHandler::Default</span> =&gt; <span class="ident">SIG_DFL</span>,
                <span class="kw">_</span> =&gt; <span class="ident">signal_receiver</span> <span class="kw">as</span> <span class="ident">usize</span>,
            };
            <span class="kw">unsafe</span> {
                <span class="comment">// SAFETY: we&#39;re using a correct value for the hook</span>
                <span class="ident">install_hook</span>(<span class="self">self</span>.<span class="ident">signal</span>, <span class="ident">hook_val</span>, <span class="ident">new_flags</span>)<span class="question-mark">?</span>
            }
        }
        <span class="prelude-val">Ok</span>(())
    }

    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">flags_as_i32</span>(<span class="self">self</span>) -&gt; <span class="ident">i32</span> {
        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">handler</span>.<span class="ident">unwrap_or_default</span>().<span class="ident">is_default</span>() {
            <span class="macro">debug_assert_eq!</span>(
                <span class="self">self</span>.<span class="ident">recursive_handler</span>, <span class="bool-val">false</span>,
                <span class="string">&quot;cannot use the recursive_handler flag with the default handling method&quot;</span>,
            );
        }
        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">signal</span> <span class="op">!</span><span class="op">=</span> <span class="ident">SIGCHLD</span> {
            <span class="macro">debug_assert_eq!</span>(
                <span class="self">self</span>.<span class="ident">ignore_child_stop_events</span>, <span class="bool-val">false</span>,
                <span class="string">&quot;cannot use the ignore_child_stop_events flag when the signal to be handled isn&#39;t \
                ChildProcessEvent&quot;</span>,
            );
        }
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">flags</span> <span class="op">=</span> <span class="number">0</span>;
        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">auto_reset_handler</span> {
            <span class="ident">flags</span> <span class="op">|</span><span class="op">=</span> <span class="ident">SA_RESETHAND</span>;
        }
        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">ignore_child_stop_events</span> {
            <span class="ident">flags</span> <span class="op">|</span><span class="op">=</span> <span class="ident">SA_NOCLDSTOP</span>;
        }
        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">recursive_handler</span> {
            <span class="ident">flags</span> <span class="op">|</span><span class="op">=</span> <span class="ident">SA_NODEFER</span>;
        }
        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">system_call_restart</span> {
            <span class="ident">flags</span> <span class="op">|</span><span class="op">=</span> <span class="ident">SA_RESTART</span>;
        }
        <span class="ident">flags</span>
    }
}

<span class="doccomment">/// The error produced when setting a signal handler fails.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">all</span>(<span class="ident">unix</span>, <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;signals&quot;</span>), <span class="ident">derive</span>(<span class="ident">Error</span>))]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">SetHandlerError</span> {
    <span class="doccomment">/// An unsafe signal was attempted to be handled using `set` instead of `set_unsafe`.</span>
    <span class="attribute">#[<span class="ident">cfg_attr</span>(
        <span class="ident">all</span>(<span class="ident">unix</span>, <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;signals&quot;</span>),
        <span class="ident">error</span>(<span class="string">&quot;an unsafe signal was attempted to be handled using `set` instead of `set_unsafe`&quot;</span>)
    )]</span>
    <span class="ident">UnsafeSignal</span>,
    <span class="doccomment">/// The signal which was attempted to be handled is not allowed to be handled by the POSIX specification. This can either be [`ForceSuspend`] or [`Kill`].</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`Kill`]: enum.SignalType.html#variant.Kill &quot; &quot;</span>
    <span class="doccomment">/// [`ForceSuspend`]: enum.SignalType.html#variant.ForceSuspend &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">cfg_attr</span>(
        <span class="ident">all</span>(<span class="ident">unix</span>, <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;signals&quot;</span>),
        <span class="ident">error</span>(<span class="string">&quot;the signal {:?} cannot be handled&quot;</span>, .<span class="number">0</span>),
    )]</span>
    <span class="ident">UnblockableSignal</span>(<span class="ident">SignalType</span>),
    <span class="doccomment">/// The specified real-time signal is not available on this OS.</span>
    <span class="attribute">#[<span class="ident">cfg_attr</span>(
        <span class="ident">all</span>(<span class="ident">unix</span>, <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;signals&quot;</span>),
        <span class="ident">error</span>(
            <span class="string">&quot;the real-time signal number {} is not available ({} is the highest possible)&quot;</span>,
            .<span class="ident">attempted</span>,
            .<span class="ident">max</span>,
        ),
    )]</span>
    <span class="ident">RealTimeSignalOutOfBounds</span> {
        <span class="doccomment">/// The realtime signal which was attempted to be used.</span>
        <span class="ident">attempted</span>: <span class="ident">u32</span>,
        <span class="doccomment">/// The highest available realtime signal number.</span>
        <span class="ident">max</span>: <span class="ident">u32</span>,
    },
    <span class="doccomment">/// An unexpected OS error ocurred during signal handler setup.</span>
    <span class="attribute">#[<span class="ident">cfg_attr</span>(
        <span class="ident">all</span>(<span class="ident">unix</span>, <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;signals&quot;</span>),
        <span class="ident">error</span>(<span class="string">&quot;{}&quot;</span>, .<span class="number">0</span>),
    )]</span>
    <span class="ident">UnexpectedSystemCallFailure</span>(<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">all</span>(<span class="ident">unix</span>, <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;signals&quot;</span>), <span class="ident">from</span>)]</span> <span class="ident">io::Error</span>),
}

<span class="doccomment">/// The actual hook which is passed to `sigaction` which dispatches signals according to the global handler map (the `HANDLERS` static).</span>
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> <span class="ident">signal_receiver</span>(<span class="ident">signum</span>: <span class="ident">i32</span>) {
    <span class="kw">let</span> <span class="ident">catched</span> <span class="op">=</span> <span class="ident">panic::catch_unwind</span>(<span class="op">|</span><span class="op">|</span> {
        <span class="kw">let</span> <span class="ident">handler_and_flags</span> <span class="op">=</span> {
            <span class="kw">let</span> <span class="ident">handlers</span> <span class="op">=</span> <span class="ident">HANDLERS</span>.<span class="ident">read</span>();
            <span class="kw">let</span> <span class="ident">val</span> <span class="op">=</span> <span class="ident">handlers</span>
                .<span class="ident">get</span>(<span class="ident">signum</span> <span class="kw">as</span> <span class="ident">u64</span>)
                .<span class="ident">expect</span>(<span class="string">&quot;unregistered signal passed by the OS to the shared receiver&quot;</span>);
            <span class="kw-2">*</span><span class="ident">val</span>
        };
        <span class="kw">match</span> <span class="ident">handler_and_flags</span>.<span class="number">0</span> {
            <span class="ident">SignalHandler::Ignore</span> =&gt; {}
            <span class="ident">SignalHandler::Hook</span>(<span class="ident">hook</span>) =&gt; <span class="ident">hook</span>.<span class="ident">inner</span>()(),
            <span class="ident">SignalHandler::Default</span> =&gt; <span class="macro">unreachable!</span>(
                <span class="string">&quot;signal receiver was unregistered but has been called by the OS anyway&quot;</span>
            ),
        }
        <span class="kw">if</span> <span class="ident">handler_and_flags</span>.<span class="number">1</span> <span class="op">&amp;</span> <span class="ident">SA_RESETHAND</span> <span class="op">!</span><span class="op">=</span> <span class="number">0</span> {
            <span class="comment">// If the signal is set to be reset to default handling, set the record accordingly.</span>
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">handlers</span> <span class="op">=</span> <span class="ident">HANDLERS</span>.<span class="ident">write</span>();
            <span class="ident">handlers</span>.<span class="ident">remove</span>(<span class="ident">signum</span> <span class="kw">as</span> <span class="ident">u64</span>);
            <span class="kw">let</span> <span class="ident">handler_and_flags</span> <span class="op">=</span> (<span class="ident">SignalHandler::Default</span>, <span class="ident">handler_and_flags</span>.<span class="number">1</span>);
            <span class="ident">handlers</span>.<span class="ident">insert</span>(<span class="ident">signum</span> <span class="kw">as</span> <span class="ident">u64</span>, <span class="ident">handler_and_flags</span>);
        }
    });
    <span class="comment">// The panic hook already ran, so we only have to abort the process</span>
    <span class="ident">catched</span>.<span class="ident">unwrap_or_else</span>(<span class="op">|</span><span class="kw">_</span><span class="op">|</span> <span class="ident">process::abort</span>());
}

<span class="doccomment">/// A signal handling method.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">SignalHandler</span> {
    <span class="doccomment">/// Use the default behavior specified by POSIX.</span>
    <span class="ident">Default</span>,
    <span class="doccomment">/// Ignore the signal whenever it is received.</span>
    <span class="ident">Ignore</span>,
    <span class="doccomment">/// Call a function whenever the signal is received.</span>
    <span class="ident">Hook</span>(<span class="ident">SignalHook</span>),
}
<span class="kw">impl</span> <span class="ident">SignalHandler</span> {
    <span class="doccomment">/// Returns `true` for the [`Default`] variant, `false` otherwise.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`Default`]: #variant.Default.html &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">is_default</span>(<span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="macro">matches!</span>(<span class="self">self</span>, <span class="ident"><span class="self">Self</span>::Default</span>)
    }
    <span class="doccomment">/// Returns `true` for the [`Ignore`] variant, `false` otherwise.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`Ignore`]: #variant.Ignore.html &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">is_ignore</span>(<span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="macro">matches!</span>(<span class="self">self</span>, <span class="ident"><span class="self">Self</span>::Ignore</span>)
    }
    <span class="doccomment">/// Returns `true` for the [`Hook`] variant, `false` otherwise.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`Hook`]: #variant.Hook.html &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">is_hook</span>(<span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="macro">matches!</span>(<span class="self">self</span>, <span class="ident"><span class="self">Self</span>::Hook</span>(..))
    }
    <span class="doccomment">/// Creates a handler which calls the specified function.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Safety</span>
    <span class="doccomment">/// The function must not call any C functions which are not considered signal-safe. See the [module-level section on signal-safe C functions] for more.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [module-level section on signal-safe C functions]: index.html#signal-safe-c-functions &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">from_fn</span>(<span class="ident">function</span>: <span class="kw">fn</span>()) -&gt; <span class="self">Self</span> {
        <span class="ident"><span class="self">Self</span>::Hook</span>(<span class="ident">SignalHook::from_fn</span>(<span class="ident">function</span>))
    }
}
<span class="kw">impl</span> <span class="ident">Default</span> <span class="kw">for</span> <span class="ident">SignalHandler</span> {
    <span class="doccomment">/// Returns [`SignalHandler::Default`].</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`SignalHandler::Default`]: #variant.Default &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">default</span>() -&gt; <span class="self">Self</span> {
        <span class="ident"><span class="self">Self</span>::Default</span>
    }
}
<span class="kw">impl</span> <span class="ident">From</span><span class="op">&lt;</span><span class="ident">SignalHook</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">SignalHandler</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">op</span>: <span class="ident">SignalHook</span>) -&gt; <span class="self">Self</span> {
        <span class="ident"><span class="self">Self</span>::Hook</span>(<span class="ident">op</span>)
    }
}
<span class="doccomment">/// A function which can be used as a signal handler.</span>
<span class="attribute">#[<span class="ident">repr</span>(<span class="ident">transparent</span>)]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">SignalHook</span>(<span class="kw">fn</span>());
<span class="kw">impl</span> <span class="ident">SignalHook</span> {
    <span class="doccomment">/// Creates a hook which calls the specified function.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Safety</span>
    <span class="doccomment">/// The function must not call any C functions which are not considered signal-safe. See the [module-level section on signal-safe C functions] for more.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [module-level section on signal-safe C functions]: index.html#signal-safe-c-functions &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">from_fn</span>(<span class="ident">function</span>: <span class="kw">fn</span>()) -&gt; <span class="self">Self</span> {
        <span class="self">Self</span>(<span class="ident">function</span>)
    }
    <span class="doccomment">/// Returns the wrapped function.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">inner</span>(<span class="self">self</span>) -&gt; <span class="kw">fn</span>() {
        <span class="self">self</span>.<span class="number">0</span>
    }
}
<span class="kw">impl</span> <span class="ident">From</span><span class="op">&lt;</span><span class="ident">SignalHook</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="kw">fn</span>() {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">op</span>: <span class="ident">SignalHook</span>) -&gt; <span class="self">Self</span> {
        <span class="ident">op</span>.<span class="number">0</span>
    }
}

<span class="doccomment">/// Sends the specified signal to the specified process. If the specified signal is `None`, no signal is sent and only a privilege check is performed instead.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Example</span>
<span class="doccomment">/// ```no_run</span>
<span class="doccomment">/// # fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span>
<span class="doccomment">/// # #[cfg(all(unix, feature = &quot;signals&quot;))] {</span>
<span class="doccomment">/// use interprocess::os::unix::signal::{self, SignalType};</span>
<span class="doccomment">/// use std::process;</span>
<span class="doccomment">///</span>
<span class="doccomment">/// // Send a Termination signal to the calling process.</span>
<span class="doccomment">/// signal::send(SignalType::Termination, process::id())?;</span>
<span class="doccomment">/// # }</span>
<span class="doccomment">/// # Ok(()) }</span>
<span class="doccomment">/// ```</span>
<span class="attribute">#[<span class="ident">inline</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">send</span>(<span class="ident">signal</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">SignalType</span><span class="op">&gt;</span><span class="op">&gt;</span>, <span class="ident">pid</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">pid</span> <span class="op">=</span>
        <span class="ident">i32::try_from</span>(<span class="ident">pid</span>.<span class="ident">into</span>()).<span class="ident">unwrap_or_else</span>(<span class="op">|</span><span class="kw">_</span><span class="op">|</span> <span class="macro">panic!</span>(<span class="string">&quot;process identifier out of range&quot;</span>));
    <span class="macro">debug_assert_ne!</span>(
        <span class="ident">pid</span>, <span class="number">0</span>,
        <span class="string">&quot;to send the signal to the process group of the calling process, use send_to_group instead&quot;</span>
    );
    <span class="kw">let</span> <span class="ident">success</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">libc::kill</span>(<span class="ident">signal</span>.<span class="ident">into</span>().<span class="ident">map_or</span>(<span class="number">0</span>, <span class="ident">Into::into</span>), <span class="ident">pid</span>) <span class="op">!</span><span class="op">=</span> <span class="op">-</span><span class="number">1</span> };
    <span class="kw">if</span> <span class="ident">success</span> {
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">io::Error::last_os_error</span>())
    }
}
<span class="doccomment">/// Sends the specified real-time signal to the specified process. If the specified signal is `None`, no signal is sent and only a privilege check is performed instead.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Example</span>
<span class="doccomment">/// ```no_run</span>
<span class="doccomment">/// # fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span>
<span class="doccomment">/// # #[cfg(all(unix, feature = &quot;signals&quot;))] {</span>
<span class="doccomment">/// use interprocess::os::unix::signal::{self, SignalType};</span>
<span class="doccomment">/// use std::process;</span>
<span class="doccomment">///</span>
<span class="doccomment">/// // Send a real-timne signal 0 to the calling process.</span>
<span class="doccomment">/// signal::send_rt(0, process::id())?;</span>
<span class="doccomment">/// # }</span>
<span class="doccomment">/// # Ok(()) }</span>
<span class="doccomment">/// ```</span>
<span class="attribute">#[<span class="ident">inline</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">send_rt</span>(<span class="ident">signal</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span>, <span class="ident">pid</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">pid</span> <span class="op">=</span>
        <span class="ident">i32::try_from</span>(<span class="ident">pid</span>.<span class="ident">into</span>()).<span class="ident">unwrap_or_else</span>(<span class="op">|</span><span class="kw">_</span><span class="op">|</span> <span class="macro">panic!</span>(<span class="string">&quot;process identifier out of range&quot;</span>));
    <span class="macro">debug_assert_ne!</span>(
        <span class="ident">pid</span>, <span class="number">0</span>,
        <span class="string">&quot;to send the signal to the process group of the calling process, use send_to_group instead&quot;</span>
    );
    <span class="kw">let</span> <span class="ident">signal</span> <span class="op">=</span> <span class="ident">signal</span>.<span class="ident">into</span>().<span class="ident">map_or</span>(<span class="number">0</span>, <span class="op">|</span><span class="ident">val</span><span class="op">|</span> {
        <span class="macro">assert!</span>(<span class="ident">is_valid_rtsignal</span>(<span class="ident">val</span>), <span class="string">&quot;invalid real-time signal&quot;</span>);
        <span class="ident">val</span>
    }) <span class="kw">as</span> <span class="ident">i32</span>;
    <span class="kw">let</span> <span class="ident">success</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">libc::kill</span>(<span class="ident">signal</span>, <span class="ident">pid</span>) <span class="op">!</span><span class="op">=</span> <span class="op">-</span><span class="number">1</span> };
    <span class="kw">if</span> <span class="ident">success</span> {
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">io::Error::last_os_error</span>())
    }
}
<span class="doccomment">/// Sends the specified signal to the specified process group. If the specified signal is `None`, no signal is sent and only a privilege check is performed instead.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Example</span>
<span class="doccomment">/// ```no_run</span>
<span class="doccomment">/// # fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span>
<span class="doccomment">/// # #[cfg(all(unix, feature = &quot;signals&quot;))] {</span>
<span class="doccomment">/// use interprocess::os::unix::signal::{self, SignalType};</span>
<span class="doccomment">/// use std::process;</span>
<span class="doccomment">///</span>
<span class="doccomment">/// // Send a Termination signal to the process group of the calling process.</span>
<span class="doccomment">/// signal::send_to_group(SignalType::Termination, 0_u32)?;</span>
<span class="doccomment">/// # }</span>
<span class="doccomment">/// # Ok(()) }</span>
<span class="doccomment">/// ```</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">send_to_group</span>(<span class="ident">signal</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">SignalType</span><span class="op">&gt;</span><span class="op">&gt;</span>, <span class="ident">pid</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">clippy::neg_multiply</span>)]</span> <span class="comment">// &quot;it&#39;s more readable to just negate&quot;? how about no</span>
    <span class="kw">let</span> <span class="ident">pid</span> <span class="op">=</span> <span class="ident">i32::try_from</span>(<span class="ident">pid</span>.<span class="ident">into</span>())
        .<span class="ident">unwrap_or_else</span>(<span class="op">|</span><span class="kw">_</span><span class="op">|</span> <span class="macro">panic!</span>(<span class="string">&quot;process group identifier out of range&quot;</span>))
        <span class="op">*</span> <span class="op">-</span><span class="number">1</span>;
    <span class="kw">let</span> <span class="ident">success</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">libc::kill</span>(<span class="ident">signal</span>.<span class="ident">into</span>().<span class="ident">map_or</span>(<span class="number">0</span>, <span class="ident">Into::into</span>), <span class="ident">pid</span>) <span class="op">!</span><span class="op">=</span> <span class="op">-</span><span class="number">1</span> };
    <span class="kw">if</span> <span class="ident">success</span> {
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">io::Error::last_os_error</span>())
    }
}
<span class="doccomment">/// Sends the specified real-time signal to the specified process. If the specified signal is `None`, no signal is sent and only a privilege check is performed instead.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # Example</span>
<span class="doccomment">/// ```no_run</span>
<span class="doccomment">/// # fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span>
<span class="doccomment">/// # #[cfg(all(unix, feature = &quot;signals&quot;))] {</span>
<span class="doccomment">/// use interprocess::os::unix::signal::{self, SignalType};</span>
<span class="doccomment">/// use std::process;</span>
<span class="doccomment">///</span>
<span class="doccomment">/// // Send a real-timne signal 0 to the process group of the calling process.</span>
<span class="doccomment">/// signal::send_rt(0_u32, 0_u32)?;</span>
<span class="doccomment">/// # }</span>
<span class="doccomment">/// # Ok(()) }</span>
<span class="doccomment">/// ```</span>
<span class="attribute">#[<span class="ident">inline</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">send_rt_to_group</span>(<span class="ident">signal</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span>, <span class="ident">pid</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">clippy::neg_multiply</span>)]</span>
    <span class="kw">let</span> <span class="ident">pid</span> <span class="op">=</span> <span class="ident">i32::try_from</span>(<span class="ident">pid</span>.<span class="ident">into</span>())
        .<span class="ident">unwrap_or_else</span>(<span class="op">|</span><span class="kw">_</span><span class="op">|</span> <span class="macro">panic!</span>(<span class="string">&quot;process identifier out of range&quot;</span>))
        <span class="op">*</span> <span class="op">-</span><span class="number">1</span>;
    <span class="macro">debug_assert_ne!</span>(
        <span class="ident">pid</span>, <span class="number">0</span>,
        <span class="string">&quot;to send the signal to the process group of the calling process, use send_to_group instead&quot;</span>
    );
    <span class="kw">let</span> <span class="ident">signal</span> <span class="op">=</span> <span class="ident">signal</span>.<span class="ident">into</span>().<span class="ident">map_or</span>(<span class="number">0</span>, <span class="op">|</span><span class="ident">val</span><span class="op">|</span> {
        <span class="macro">assert!</span>(<span class="ident">is_valid_rtsignal</span>(<span class="ident">val</span>), <span class="string">&quot;invalid real-time signal&quot;</span>);
        <span class="ident">val</span>
    }) <span class="kw">as</span> <span class="ident">i32</span>;
    <span class="kw">let</span> <span class="ident">success</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">libc::kill</span>(<span class="ident">signal</span>, <span class="ident">pid</span>) <span class="op">!</span><span class="op">=</span> <span class="op">-</span><span class="number">1</span> };
    <span class="kw">if</span> <span class="ident">success</span> {
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">io::Error::last_os_error</span>())
    }
}

<span class="doccomment">/// All standard signal types as defined in POSIX.1-2001.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The values can be safely and quickly converted to [`i32`]/[`u32`]. The reverse process involves safety checks, making sure that unknown signal values are never stored.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// [`i32`]: https://doc.rust-lang.org/std/primitive.i32.html &quot; &quot;</span>
<span class="doccomment">/// [`u32`]: https://doc.rust-lang.org/std/primitive.u32.html &quot; &quot;</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>, <span class="ident">Hash</span>)]</span>
<span class="attribute">#[<span class="ident">repr</span>(<span class="ident">i32</span>)]</span>
<span class="attribute">#[<span class="ident">non_exhaustive</span>]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">SignalType</span> {
    <span class="doccomment">/// `SIGHUP` — lost connection to controlling terminal. Opting out of this signal is recommended if the process does not need to stop after the user who started it logs out.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination.*</span>
    <span class="ident">Hangup</span> <span class="op">=</span> <span class="ident">SIGHUP</span>,
    <span class="doccomment">/// `SIGINT` — keyboard interrupt, usually sent by pressing `Ctrl`+`C` by the terminal. This signal is typically set to be ignored if the program runs an interactive interface: GUI/TUI, interactive shell (the Python shell, for example) or any other kind of interface which runs in a loop, as opposed to a command-line invocation of the program which reads its standard input or command-line arguments, performs a task and exits. If the interactive interface is running a lengthy operation, a good idea is to temporarily re-enable the signal and abort the lengthy operation if the signal is received, then disable it again.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination.*</span>
    <span class="ident">KeyboardInterrupt</span> <span class="op">=</span> <span class="ident">SIGINT</span>,
    <span class="doccomment">/// `SIGQUIT` — request to perform a core dump and quit, usually sent by pressing `Ctrl`+`\`. This signal normally should not be overriden or masked out — the core dump is performed automatically by the OS.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination with a core dump.*</span>
    <span class="ident">QuitAndDump</span> <span class="op">=</span> <span class="ident">SIGQUIT</span>,
    <span class="doccomment">/// `SIGILL` — illegal or malformed instruction exception, generated by the CPU whenever such an instruction is executed. This signal normally should not be overriden or masked out, since it likely means that the executable file or the memory of the process has been corrupted and further execution is a risk of invoking negative consequences.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// For reasons described above, **this signal is considered unsafe** — handling it requires using `set_unsafe_handler`.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination with a core dump.*</span>
    <span class="ident">IllegalInstruction</span> <span class="op">=</span> <span class="ident">SIGILL</span>,
    <span class="doccomment">/// `SIGABRT` — abnormal termination requested. This signal is typically invoked by the program itself, using [`std::process::abort`] or the equivalent C function; still, like any other signal, it can be sent from outside the process.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination with a core dump.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`std::process::abort`]: https://doc.rust-lang.org/std/process/fn.abort.html &quot; &quot;</span>
    <span class="ident">Abort</span> <span class="op">=</span> <span class="ident">SIGABRT</span>,
    <span class="doccomment">/// `SIGFPE` — mathematical exception. This signal is generated whenever an undefined mathematical operation is performed — mainly integer division by zero.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination with a core dump.*</span>
    <span class="ident">MathException</span> <span class="op">=</span> <span class="ident">SIGFPE</span>,
    <span class="doccomment">/// `SIGKILL` — forced termination. This signal can only be sent using the usual signal sending procedures and, unlike most other signals, cannot be masked out or handled at all. The main purpose for this signal is to stop a program which has masked out all other signals for malicious purposes or has stuck in such a state because of a bug.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination, **cannot be overriden or disabled**.*</span>
    <span class="ident">Kill</span> <span class="op">=</span> <span class="ident">SIGKILL</span>,
    <span class="doccomment">/// `SIGSEGV` — invaid memory access. This signal is issued by the OS whenever the program tries to access an invalid memory location, such as the `NULL` pointer or simply an address outside the user-mode address space as established by the OS. The only case when this signal can be received by a Rust program is if memory unsafety occurs due to misuse of unsafe code. As such, it should normally not be masked out or handled, as it likely indicates a critical bug (soundness hole), executable file corruption or process memory corruption.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// For reasons described above, **this signal is considered unsafe** — handling it requires using `set_unsafe_handler`.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination with a core dump.*</span>
    <span class="ident">SegmentationFault</span> <span class="op">=</span> <span class="ident">SIGSEGV</span>,
    <span class="doccomment">/// `SIGPIPE` — invalid access to an [unnamed pipe]. This signal is issued by the OS whenever a program attempts to write to an unnamed pipe which has no readers connected to it. If unexpected, this might mean abnormal termination of the process which the pipe was used to communicate with.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [unnamed pipe]: ../../../unnamed_pipe/index.html &quot; &quot;</span>
    <span class="ident">BrokenPipe</span> <span class="op">=</span> <span class="ident">SIGPIPE</span>,
    <span class="doccomment">/// `SIGALRM` — &quot;alarm clock&quot; signal. This signal is issued by the OS when the arranged amount of real (wall clock) time expires. This clock can be set using the [`alarm`] and [`setitimer`] system calls.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`alarm`]: https://www.man7.org/linux/man-pages/man2/alarm.2.html &quot; &quot;</span>
    <span class="doccomment">/// [`setitimer`]: https://www.man7.org/linux/man-pages/man2/setitimer.2.html &quot; &quot;</span>
    <span class="ident">AlarmClock</span> <span class="op">=</span> <span class="ident">SIGALRM</span>,
    <span class="doccomment">/// `SIGTERM` — request for termination. This signal can only be sent using the usual signal sending procedures. Unlike [`KeyboardInterrupt`], this signal is not a request to break out of a lengthy operation, but rather to close the program as a whole. Signal handlers for this signal are expected to perform minimal cleanup and quick state save procedures and then exit.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`KeyboardInterrupt`]: #variant.KeyboardInterrupt &quot; &quot;</span>
    <span class="ident">Termination</span> <span class="op">=</span> <span class="ident">SIGTERM</span>,
    <span class="doccomment">/// `SIGUSR1` — user-defined signal 1. This signal, like [`UserSignal2`], does not have a predefined meaning and is not produced by the OS. For this reason, it is typically used for interprocess communication between two programs familiar with each other, or in language runtimes to signal certain events, such as externally activated immediate garbage collection.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`UserSignal2`]: #variant.UserSignal2 &quot; &quot;</span>
    <span class="ident">UserSignal1</span> <span class="op">=</span> <span class="ident">SIGUSR1</span>,
    <span class="doccomment">/// `SIGUSR2` — user-defined signal 2. This signal is similar to [`UserSignal1`] and has the same properties, but is a distinct signal nonetheless.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`UserSignal1`]: #variant.UserSignal1 &quot; &quot;</span>
    <span class="ident">UserSignal2</span> <span class="op">=</span> <span class="ident">SIGUSR2</span>,
    <span class="doccomment">/// `SIGCHLD` — child process suspended, resumed or terminated. This signal is issued by the OS whenever a child process is suspended/resumed or terminated by a signal or otherwise.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: ignore.*</span>
    <span class="ident">ChildProcessEvent</span> <span class="op">=</span> <span class="ident">SIGCHLD</span>,
    <span class="doccomment">/// `SIGCONT` — resume the process after being suspended. This signal can be sent to a process by an external program when it wishes to resume that process after it being suspended in a stopped state.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: continue execution.*</span>
    <span class="ident">Continue</span> <span class="op">=</span> <span class="ident">SIGCONT</span>,
    <span class="doccomment">/// `SIGSTOP` — forcefully stop a process temporarily. This signal can only be sent to a process by an external program. Unlike [`Suspend`], this signal cannot be masked out or handled, i.e. it is guaranteed to be able to temporarily stop a process from executing without [forcefully terminating it]. The process can then be restarted using [`Continue`].</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: temporarily stop process, **cannot be overriden or disabled**.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`Suspend`]: #variant.Suspend &quot; &quot;</span>
    <span class="doccomment">/// [forcefully terminating it]: #variant.Kill &quot; &quot;</span>
    <span class="doccomment">/// [`Continue`]: #variant.Continue &quot; &quot;</span>
    <span class="ident">ForceSuspend</span> <span class="op">=</span> <span class="ident">SIGSTOP</span>,
    <span class="doccomment">/// `SIGTSTP` — temporarily stop a process. This signal can only be sent to a process by an external program. Unlike [`ForceSuspend`], this signal can be masked out or handled by the process which is requested to stop. The process can then be restarted using [`Continue`].</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: temporarily stop process.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`ForceSuspend`]: #variant.ForceSuspend &quot; &quot;</span>
    <span class="doccomment">/// [`Continue`]: #variant.Continue &quot; &quot;</span>
    <span class="ident">Suspend</span> <span class="op">=</span> <span class="ident">SIGTSTP</span>,
    <span class="doccomment">/// `SIGTTIN` — attempt to read from standard input while in the background. This signal is issued by the OS whenever a process which is under [job control] tries to read from standard input but is in the background, i.e. temporarily detached from the terminal.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: temporarily stop process.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [job control]: https://en.wikipedia.org/wiki/Job_control_(Unix) &quot; &quot;</span>
    <span class="ident">TerminalInputWhileInBackground</span> <span class="op">=</span> <span class="ident">SIGTTIN</span>,
    <span class="doccomment">/// `SIGTTOU` — attempt to write to standard output while in the background. This signal is issued by the OS whenever a process which is under [job control] tries to write to standard input but is in the background, i.e. temporarily detached from the terminal.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: temporarily stop process.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [job control]: https://en.wikipedia.org/wiki/Job_control_(Unix) &quot; &quot;</span>
    <span class="ident">TerminalOutputWhileInBackground</span> <span class="op">=</span> <span class="ident">SIGTTOU</span>,
    <span class="doccomment">/// `SIGPOLL` — watched file descriptor event. This signal is issued by the OS when a file descriptor which has been enabled to interact with this signal has a state update.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination.*</span>
    <span class="comment">// TODO more on this</span>
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">doc</span>, <span class="ident">not</span>(<span class="ident">any</span>(<span class="ident">target_os</span> <span class="op">=</span> <span class="string">&quot;macos&quot;</span>, <span class="ident">target_os</span> <span class="op">=</span> <span class="string">&quot;ios&quot;</span>,)),))]</span>
    <span class="attribute">#[<span class="ident">cfg_attr</span>(
        <span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;doc_cfg&quot;</span>,
        <span class="ident">doc</span>(<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">any</span>(<span class="ident">target_os</span> <span class="op">=</span> <span class="string">&quot;macos&quot;</span>, <span class="ident">target_os</span> <span class="op">=</span> <span class="string">&quot;ios&quot;</span>,)),))
    )]</span>
    <span class="ident">PollNotification</span> <span class="op">=</span> <span class="ident">SIGPOLL</span>,
    <span class="doccomment">/// `SIGBUS` — [bus error]. This signal is issued by the OS when a process does one of the following:</span>
    <span class="doccomment">/// - **Tries to access an invalid physical address**. Normally, this should never happen — attempts to access invalid *virtual* memory are handled as [segmentation faults], and invalid phyiscal addresses are typically not present in the address space of a program in user-mode.</span>
    <span class="doccomment">/// - **Performs an incorrectly aligned memory access**. In Rust, this can only happen if unsafe code is misused to construct an incorrectly aligned pointer to a type which requires alignment which is more strict than simple one byte alignment. This is a direct sign of memory unsafety being invoked.</span>
    <span class="doccomment">/// - **Incorrect x86 segment register**. This can only be acheieved using inline assembly or FFI (calling an external function written in assembly language or with usage of C/C++ inline assembly), and only on the x86 architecture. If an invalid value is loaded into the segment registers, the CPU generates this exception. This is either a sign of a failed advanced unsafe operation or a deliberate attempt to cryptically crash the program.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// For reasons described above, **this signal is considered unsafe** — handling it requires using `set_unsafe_handler`.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination with a core dump.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [bus error]: https://en.wikipedia.org/wiki/Bus_error &quot; &quot;</span>
    <span class="doccomment">/// [segmentation faults]: #variant.SegmentationFault &quot; &quot;</span>
    <span class="ident">MemoryBusError</span> <span class="op">=</span> <span class="ident">SIGBUS</span>,
    <span class="doccomment">/// `SIGPROF` — profiler clock signal. This signal is issued by the OS when the arranged amount of CPU time expires. The time includes not only user-mode CPU time spent in the process, but also kernel-mode CPU time which the OS associates with the process. This is different from [`UserModeProfilerClock`]&#39;s behavior, which counts only user-mode CPU time. This clock can be set using the [`setitimer`] system call.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`UserModeProfilerClock`]: #variant.UserModeProfilerClock &quot; &quot;</span>
    <span class="doccomment">/// [`setitimer`]: https://www.man7.org/linux/man-pages/man2/setitimer.2.html &quot; &quot;</span>
    <span class="ident">ProfilerClock</span> <span class="op">=</span> <span class="ident">SIGPROF</span>,
    <span class="doccomment">/// `SIGVTALRM` — user-mode profiler clock signal. This signal is issued by the OS when the arranged amount of CPU time expires. Only user-mode CPU time is counted, in contrast to `ProfilerClock`, which counts kernel-mode time associated by the system with the process as well. This clock can be set using the [`setitimer`] system call.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`ProfilerClock`]: #variant.ProfilerClock &quot; &quot;</span>
    <span class="doccomment">/// [`setitimer`]: https://www.man7.org/linux/man-pages/man2/setitimer.2.html &quot; &quot;</span>
    <span class="ident">UserModeProfilerClock</span> <span class="op">=</span> <span class="ident">SIGVTALRM</span>,
    <span class="doccomment">/// `SIGSYS` — attempt to perform an invalid system call. This signal is issued by the OS when a system call receives invalid arguments. Normally, the C library functions used to perform system calls in Rust programs do not generate this signal — the only way to generate it is to send it to a process explicitly, use raw system call instructions or violate [`seccomp`] rules if it is enabled.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination with a core dump.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`seccomp`]: https://en.wikipedia.org/wiki/Seccomp &quot; &quot;</span>
    <span class="ident">InvalidSystemCall</span> <span class="op">=</span> <span class="ident">SIGSYS</span>,
    <span class="doccomment">/// `SIGTRAP` — software breakpoint. This signal is issued by the OS when a breakpoint instruction is executed. On x86, the instruction to do so is `int 3`. This instruction is typically inserted by debuggers and code injection utilities.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination with a core dump.*</span>
    <span class="ident">Breakpoint</span> <span class="op">=</span> <span class="ident">SIGTRAP</span>,
    <span class="doccomment">/// `SIGURG` — [out-of-band data] received on a socket. This signal is issued by the OS when a socket owned by the process receives urgent out-of-band data.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: ignore.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [out-of-band data]: https://en.wikipedia.org/wiki/Out-of-band_data &quot; &quot;</span>
    <span class="ident">OutOfBandDataAvailable</span> <span class="op">=</span> <span class="ident">SIGURG</span>,
    <span class="doccomment">/// `SIGXCPU` — assigned CPU time limit for the process was exceeded. This signal is issued by the OS if a CPU time limit for the process was set, when that limit expires. If not handled quickly, the system will issue a [`Kill`] signal to shut down the process forcefully, i.e. ignoring this signal won&#39;t lead to bypassing the limit. The [`setrlimit`] system call is used to set the soft limit for this signal and the hard limit, which invokes [`Kill`].</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination with a core dump.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`setrlimit`]: https://www.man7.org/linux/man-pages/man2/setrlimit.2.html &quot; &quot;</span>
    <span class="doccomment">/// [`Kill`]: #variant.Kill &quot; &quot;</span>
    <span class="ident">CpuTimeLimitExceeded</span> <span class="op">=</span> <span class="ident">SIGXCPU</span>,
    <span class="doccomment">/// `SIGXFSZ` — assigned file size limit for the process was exceeded. This signal is issued by the OS if a limit on the size of files which are written to by the process was set, when that limit is exceeded by the process. If ignored/handled, the offending system call fails with an error regardless of the handling method. The [`setrlimit`] system call is used to set the limit.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// *Default handler: process termination with a core dump.*</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`setrlimit`]: https://www.man7.org/linux/man-pages/man2/setrlimit.2.html &quot; &quot;</span>
    <span class="ident">FileSizeLimitExceeded</span> <span class="op">=</span> <span class="ident">SIGXFSZ</span>,
}
<span class="kw">impl</span> <span class="ident">SignalType</span> {
    <span class="doccomment">/// Returns `true` if the value is a special signal which cannot be blocked or handled ([`Kill`] or [`ForceSuspend`]), `false` otherwise.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// [`Kill`]: #variant.Kill &quot; &quot;</span>
    <span class="doccomment">/// [`ForceSuspend`]: #variant.ForceSuspend &quot; &quot;</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">is_unblockable</span>(<span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="macro">matches!</span>(<span class="self">self</span>, <span class="ident"><span class="self">Self</span>::Kill</span> <span class="op">|</span> <span class="ident"><span class="self">Self</span>::ForceSuspend</span>)
    }
    <span class="doccomment">/// Returns `true` if the value is an unsafe signal which requires unsafe code when setting a handling method, `false` otherwise.</span>
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">is_unsafe</span>(<span class="self">self</span>) -&gt; <span class="ident">bool</span> {
        <span class="macro">matches!</span>(
            <span class="self">self</span>,
            <span class="ident"><span class="self">Self</span>::SegmentationFault</span> <span class="op">|</span> <span class="ident"><span class="self">Self</span>::MemoryBusError</span> <span class="op">|</span> <span class="ident"><span class="self">Self</span>::IllegalInstruction</span>
        )
    }
}
<span class="kw">impl</span> <span class="ident">From</span><span class="op">&lt;</span><span class="ident">SignalType</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">i32</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">op</span>: <span class="ident">SignalType</span>) -&gt; <span class="self">Self</span> {
        <span class="ident">op</span> <span class="kw">as</span> <span class="ident">i32</span>
    }
}
<span class="kw">impl</span> <span class="ident">From</span><span class="op">&lt;</span><span class="ident">SignalType</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">u32</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">op</span>: <span class="ident">SignalType</span>) -&gt; <span class="self">Self</span> {
        <span class="ident">op</span> <span class="kw">as</span> <span class="ident">u32</span>
    }
}
<span class="kw">impl</span> <span class="ident">TryFrom</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">SignalType</span> {
    <span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="ident">UnknownSignalError</span>;
    <span class="kw">fn</span> <span class="ident">try_from</span>(<span class="ident">value</span>: <span class="ident">i32</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>, <span class="ident"><span class="self">Self</span>::Error</span><span class="op">&gt;</span> {
        <span class="kw">match</span> <span class="ident">value</span> {
            <span class="ident">SIGHUP</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::Hangup</span>),
            <span class="ident">SIGINT</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::KeyboardInterrupt</span>),
            <span class="ident">SIGQUIT</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::QuitAndDump</span>),
            <span class="ident">SIGILL</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::IllegalInstruction</span>),
            <span class="ident">SIGABRT</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::Abort</span>),
            <span class="ident">SIGFPE</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::MathException</span>),
            <span class="ident">SIGKILL</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::Kill</span>),
            <span class="ident">SIGSEGV</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::SegmentationFault</span>),
            <span class="ident">SIGPIPE</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::BrokenPipe</span>),
            <span class="ident">SIGALRM</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::AlarmClock</span>),
            <span class="ident">SIGTERM</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::Termination</span>),
            <span class="ident">SIGUSR1</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::UserSignal1</span>),
            <span class="ident">SIGUSR2</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::UserSignal2</span>),
            <span class="ident">SIGCHLD</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::ChildProcessEvent</span>),
            <span class="ident">SIGCONT</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::Continue</span>),
            <span class="ident">SIGSTOP</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::ForceSuspend</span>),
            <span class="ident">SIGTSTP</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::Suspend</span>),
            <span class="ident">SIGTTIN</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::TerminalInputWhileInBackground</span>),
            <span class="ident">SIGTTOU</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::TerminalOutputWhileInBackground</span>),
            <span class="ident">SIGBUS</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::MemoryBusError</span>),
            <span class="ident">SIGPROF</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::ProfilerClock</span>),
            <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(
                <span class="ident">doc</span>,
                <span class="ident">target_os</span> <span class="op">=</span> <span class="string">&quot;linux&quot;</span>,
                <span class="ident">target_os</span> <span class="op">=</span> <span class="string">&quot;emscripten&quot;</span>,
                <span class="ident">target_os</span> <span class="op">=</span> <span class="string">&quot;android&quot;</span>,
                <span class="ident">target_os</span> <span class="op">=</span> <span class="string">&quot;haiku&quot;</span>,
                <span class="ident">target_os</span> <span class="op">=</span> <span class="string">&quot;fuchsia&quot;</span>,
                <span class="ident">target_os</span> <span class="op">=</span> <span class="string">&quot;solaris&quot;</span>,
                <span class="ident">target_os</span> <span class="op">=</span> <span class="string">&quot;illumos&quot;</span>,
            ))]</span>
            <span class="ident">libc::SIGPOLL</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::PollNotification</span>),
            <span class="ident">SIGSYS</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::InvalidSystemCall</span>),
            <span class="ident">SIGTRAP</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::Breakpoint</span>),
            <span class="ident">SIGURG</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::OutOfBandDataAvailable</span>),
            <span class="ident">SIGVTALRM</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::UserModeProfilerClock</span>),
            <span class="ident">SIGXCPU</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::CpuTimeLimitExceeded</span>),
            <span class="ident">SIGXFSZ</span> =&gt; <span class="prelude-val">Ok</span>(<span class="ident"><span class="self">Self</span>::FileSizeLimitExceeded</span>),
            <span class="kw">_</span> =&gt; <span class="prelude-val">Err</span>(<span class="ident">UnknownSignalError</span> { <span class="ident">value</span> }),
        }
    }
}
<span class="kw">impl</span> <span class="ident">TryFrom</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">SignalType</span> {
    <span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="ident">UnknownSignalError</span>;
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">try_from</span>(<span class="ident">value</span>: <span class="ident">u32</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>, <span class="ident"><span class="self">Self</span>::Error</span><span class="op">&gt;</span> {
        (<span class="ident">value</span> <span class="kw">as</span> <span class="ident">u32</span>).<span class="ident">try_into</span>()
    }
}

<span class="doccomment">/// Error type returned when a conversion from [`i32`]/[`u32`] to [`SignalType`] fails.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// [`i32`]: https://doc.rust-lang.org/std/primitive.i32.html &quot; &quot;</span>
<span class="doccomment">/// [`u32`]: https://doc.rust-lang.org/std/primitive.u32.html &quot; &quot;</span>
<span class="doccomment">/// [`SignalType`]: enum.SignalType.html &quot; &quot;</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">UnknownSignalError</span> {
    <span class="doccomment">/// The unknown signal value which was encountered.</span>
    <span class="kw">pub</span> <span class="ident">value</span>: <span class="ident">i32</span>,
}
<span class="kw">impl</span> <span class="ident">Display</span> <span class="kw">for</span> <span class="ident">UnknownSignalError</span> {
    <span class="attribute">#[<span class="ident">inline</span>]</span>
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) -&gt; <span class="ident">fmt::Result</span> {
        <span class="macro">write!</span>(<span class="ident">f</span>, <span class="string">&quot;unknown signal value {}&quot;</span>, <span class="self">self</span>.<span class="ident">value</span>)
    }
}
<span class="kw">impl</span> <span class="ident">fmt::Binary</span> <span class="kw">for</span> <span class="ident">UnknownSignalError</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) -&gt; <span class="ident">fmt::Result</span> {
        <span class="macro">write!</span>(<span class="ident">f</span>, <span class="string">&quot;unknown signal value {:b}&quot;</span>, <span class="self">self</span>.<span class="ident">value</span>)
    }
}
<span class="kw">impl</span> <span class="ident">fmt::LowerHex</span> <span class="kw">for</span> <span class="ident">UnknownSignalError</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) -&gt; <span class="ident">fmt::Result</span> {
        <span class="macro">write!</span>(<span class="ident">f</span>, <span class="string">&quot;unknown signal value {:x}&quot;</span>, <span class="self">self</span>.<span class="ident">value</span>)
    }
}
<span class="kw">impl</span> <span class="ident">fmt::UpperExp</span> <span class="kw">for</span> <span class="ident">UnknownSignalError</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) -&gt; <span class="ident">fmt::Result</span> {
        <span class="macro">write!</span>(<span class="ident">f</span>, <span class="string">&quot;unknown signal value {:X}&quot;</span>, <span class="self">self</span>.<span class="ident">value</span>)
    }
}
<span class="kw">impl</span> <span class="ident">fmt::Octal</span> <span class="kw">for</span> <span class="ident">UnknownSignalError</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Formatter</span><span class="op">&lt;</span><span class="lifetime">&#39;_</span><span class="op">&gt;</span>) -&gt; <span class="ident">fmt::Result</span> {
        <span class="macro">write!</span>(<span class="ident">f</span>, <span class="string">&quot;unknown signal value {:o}&quot;</span>, <span class="self">self</span>.<span class="ident">value</span>)
    }
}
<span class="kw">impl</span> <span class="ident">Error</span> <span class="kw">for</span> <span class="ident">UnknownSignalError</span> {}
</code></pre></div>
</section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../../../" data-current-crate="interprocess" data-search-index-js="../../../../search-index.js" data-search-js="../../../../search.js"></div>
    <script src="../../../../main.js"></script><script src="../../../../source-script.js"></script><script src="../../../../source-files.js"></script>
</body></html>